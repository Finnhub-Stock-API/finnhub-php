<?php
/**
 * DefaultApi
 * PHP version 7.3
 *
 * @category Class
 * @package  Finnhub
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Finnhub API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Finnhub\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Finnhub\ApiException;
use Finnhub\Configuration;
use Finnhub\HeaderSelector;
use Finnhub\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Finnhub
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation aggregateIndicator
     *
     * Aggregate Indicators
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\AggregateIndicators
     */
    public function aggregateIndicator($symbol, $resolution)
    {
        list($response) = $this->aggregateIndicatorWithHttpInfo($symbol, $resolution);
        return $response;
    }

    /**
     * Operation aggregateIndicatorWithHttpInfo
     *
     * Aggregate Indicators
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\AggregateIndicators, HTTP status code, HTTP response headers (array of strings)
     */
    public function aggregateIndicatorWithHttpInfo($symbol, $resolution)
    {
        $request = $this->aggregateIndicatorRequest($symbol, $resolution);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\AggregateIndicators' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\AggregateIndicators', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\AggregateIndicators';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\AggregateIndicators',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation aggregateIndicatorAsync
     *
     * Aggregate Indicators
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aggregateIndicatorAsync($symbol, $resolution)
    {
        return $this->aggregateIndicatorAsyncWithHttpInfo($symbol, $resolution)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation aggregateIndicatorAsyncWithHttpInfo
     *
     * Aggregate Indicators
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aggregateIndicatorAsyncWithHttpInfo($symbol, $resolution)
    {
        $returnType = '\Finnhub\Model\AggregateIndicators';
        $request = $this->aggregateIndicatorRequest($symbol, $resolution);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'aggregateIndicator'
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function aggregateIndicatorRequest($symbol, $resolution)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling aggregateIndicator'
            );
        }
        // verify the required parameter 'resolution' is set
        if ($resolution === null || (is_array($resolution) && count($resolution) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resolution when calling aggregateIndicator'
            );
        }

        $resourcePath = '/scan/technical-indicator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($resolution)) {
            $resolution = ObjectSerializer::serializeCollection($resolution, '', true);
        }
        if ($resolution !== null) {
            $queryParams['resolution'] = $resolution;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bondPrice
     *
     * Bond price data
     *
     * @param  string $isin ISIN. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\BondCandles
     */
    public function bondPrice($isin, $from, $to)
    {
        list($response) = $this->bondPriceWithHttpInfo($isin, $from, $to);
        return $response;
    }

    /**
     * Operation bondPriceWithHttpInfo
     *
     * Bond price data
     *
     * @param  string $isin ISIN. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\BondCandles, HTTP status code, HTTP response headers (array of strings)
     */
    public function bondPriceWithHttpInfo($isin, $from, $to)
    {
        $request = $this->bondPriceRequest($isin, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\BondCandles' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\BondCandles', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\BondCandles';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\BondCandles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bondPriceAsync
     *
     * Bond price data
     *
     * @param  string $isin ISIN. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bondPriceAsync($isin, $from, $to)
    {
        return $this->bondPriceAsyncWithHttpInfo($isin, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bondPriceAsyncWithHttpInfo
     *
     * Bond price data
     *
     * @param  string $isin ISIN. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bondPriceAsyncWithHttpInfo($isin, $from, $to)
    {
        $returnType = '\Finnhub\Model\BondCandles';
        $request = $this->bondPriceRequest($isin, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bondPrice'
     *
     * @param  string $isin ISIN. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bondPriceRequest($isin, $from, $to)
    {
        // verify the required parameter 'isin' is set
        if ($isin === null || (is_array($isin) && count($isin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $isin when calling bondPrice'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling bondPrice'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling bondPrice'
            );
        }

        $resourcePath = '/bond/price';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bondProfile
     *
     * Bond Profile
     *
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     * @param  string $figi FIGI (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\BondProfile
     */
    public function bondProfile($isin = null, $cusip = null, $figi = null)
    {
        list($response) = $this->bondProfileWithHttpInfo($isin, $cusip, $figi);
        return $response;
    }

    /**
     * Operation bondProfileWithHttpInfo
     *
     * Bond Profile
     *
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     * @param  string $figi FIGI (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\BondProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function bondProfileWithHttpInfo($isin = null, $cusip = null, $figi = null)
    {
        $request = $this->bondProfileRequest($isin, $cusip, $figi);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\BondProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\BondProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\BondProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\BondProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bondProfileAsync
     *
     * Bond Profile
     *
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     * @param  string $figi FIGI (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bondProfileAsync($isin = null, $cusip = null, $figi = null)
    {
        return $this->bondProfileAsyncWithHttpInfo($isin, $cusip, $figi)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bondProfileAsyncWithHttpInfo
     *
     * Bond Profile
     *
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     * @param  string $figi FIGI (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bondProfileAsyncWithHttpInfo($isin = null, $cusip = null, $figi = null)
    {
        $returnType = '\Finnhub\Model\BondProfile';
        $request = $this->bondProfileRequest($isin, $cusip, $figi);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bondProfile'
     *
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     * @param  string $figi FIGI (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bondProfileRequest($isin = null, $cusip = null, $figi = null)
    {

        $resourcePath = '/bond/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }
        // query params
        if (is_array($cusip)) {
            $cusip = ObjectSerializer::serializeCollection($cusip, '', true);
        }
        if ($cusip !== null) {
            $queryParams['cusip'] = $cusip;
        }
        // query params
        if (is_array($figi)) {
            $figi = ObjectSerializer::serializeCollection($figi, '', true);
        }
        if ($figi !== null) {
            $queryParams['figi'] = $figi;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bondTick
     *
     * Bond Tick Data
     *
     * @param  string $isin ISIN. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     * @param  string $exchange Currently support the following values: &lt;code&gt;trace&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\BondTickData
     */
    public function bondTick($isin, $date, $limit, $skip, $exchange)
    {
        list($response) = $this->bondTickWithHttpInfo($isin, $date, $limit, $skip, $exchange);
        return $response;
    }

    /**
     * Operation bondTickWithHttpInfo
     *
     * Bond Tick Data
     *
     * @param  string $isin ISIN. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     * @param  string $exchange Currently support the following values: &lt;code&gt;trace&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\BondTickData, HTTP status code, HTTP response headers (array of strings)
     */
    public function bondTickWithHttpInfo($isin, $date, $limit, $skip, $exchange)
    {
        $request = $this->bondTickRequest($isin, $date, $limit, $skip, $exchange);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\BondTickData' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\BondTickData', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\BondTickData';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\BondTickData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bondTickAsync
     *
     * Bond Tick Data
     *
     * @param  string $isin ISIN. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     * @param  string $exchange Currently support the following values: &lt;code&gt;trace&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bondTickAsync($isin, $date, $limit, $skip, $exchange)
    {
        return $this->bondTickAsyncWithHttpInfo($isin, $date, $limit, $skip, $exchange)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bondTickAsyncWithHttpInfo
     *
     * Bond Tick Data
     *
     * @param  string $isin ISIN. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     * @param  string $exchange Currently support the following values: &lt;code&gt;trace&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bondTickAsyncWithHttpInfo($isin, $date, $limit, $skip, $exchange)
    {
        $returnType = '\Finnhub\Model\BondTickData';
        $request = $this->bondTickRequest($isin, $date, $limit, $skip, $exchange);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bondTick'
     *
     * @param  string $isin ISIN. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     * @param  string $exchange Currently support the following values: &lt;code&gt;trace&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bondTickRequest($isin, $date, $limit, $skip, $exchange)
    {
        // verify the required parameter 'isin' is set
        if ($isin === null || (is_array($isin) && count($isin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $isin when calling bondTick'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling bondTick'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling bondTick'
            );
        }
        // verify the required parameter 'skip' is set
        if ($skip === null || (is_array($skip) && count($skip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $skip when calling bondTick'
            );
        }
        // verify the required parameter 'exchange' is set
        if ($exchange === null || (is_array($exchange) && count($exchange) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange when calling bondTick'
            );
        }

        $resourcePath = '/bond/tick';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }
        // query params
        if (is_array($date)) {
            $date = ObjectSerializer::serializeCollection($date, '', true);
        }
        if ($date !== null) {
            $queryParams['date'] = $date;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($skip)) {
            $skip = ObjectSerializer::serializeCollection($skip, '', true);
        }
        if ($skip !== null) {
            $queryParams['skip'] = $skip;
        }
        // query params
        if (is_array($exchange)) {
            $exchange = ObjectSerializer::serializeCollection($exchange, '', true);
        }
        if ($exchange !== null) {
            $queryParams['exchange'] = $exchange;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bondYieldCurve
     *
     * Bond Yield Curve
     *
     * @param  string $code Bond&#39;s code. You can find the list of supported code &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1iA-lM0Kht7lsQZ7Uu_s6r2i1BbQNUNO9eGkO5-zglHg/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\BondYieldCurve
     */
    public function bondYieldCurve($code)
    {
        list($response) = $this->bondYieldCurveWithHttpInfo($code);
        return $response;
    }

    /**
     * Operation bondYieldCurveWithHttpInfo
     *
     * Bond Yield Curve
     *
     * @param  string $code Bond&#39;s code. You can find the list of supported code &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1iA-lM0Kht7lsQZ7Uu_s6r2i1BbQNUNO9eGkO5-zglHg/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\BondYieldCurve, HTTP status code, HTTP response headers (array of strings)
     */
    public function bondYieldCurveWithHttpInfo($code)
    {
        $request = $this->bondYieldCurveRequest($code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\BondYieldCurve' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\BondYieldCurve', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\BondYieldCurve';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\BondYieldCurve',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bondYieldCurveAsync
     *
     * Bond Yield Curve
     *
     * @param  string $code Bond&#39;s code. You can find the list of supported code &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1iA-lM0Kht7lsQZ7Uu_s6r2i1BbQNUNO9eGkO5-zglHg/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bondYieldCurveAsync($code)
    {
        return $this->bondYieldCurveAsyncWithHttpInfo($code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bondYieldCurveAsyncWithHttpInfo
     *
     * Bond Yield Curve
     *
     * @param  string $code Bond&#39;s code. You can find the list of supported code &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1iA-lM0Kht7lsQZ7Uu_s6r2i1BbQNUNO9eGkO5-zglHg/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bondYieldCurveAsyncWithHttpInfo($code)
    {
        $returnType = '\Finnhub\Model\BondYieldCurve';
        $request = $this->bondYieldCurveRequest($code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bondYieldCurve'
     *
     * @param  string $code Bond&#39;s code. You can find the list of supported code &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1iA-lM0Kht7lsQZ7Uu_s6r2i1BbQNUNO9eGkO5-zglHg/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bondYieldCurveRequest($code)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling bondYieldCurve'
            );
        }

        $resourcePath = '/bond/yield-curve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($code)) {
            $code = ObjectSerializer::serializeCollection($code, '', true);
        }
        if ($code !== null) {
            $queryParams['code'] = $code;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyBasicFinancials
     *
     * Basic Financials
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $metric Metric type. Can be 1 of the following values &lt;code&gt;all&lt;/code&gt; (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\BasicFinancials
     */
    public function companyBasicFinancials($symbol, $metric)
    {
        list($response) = $this->companyBasicFinancialsWithHttpInfo($symbol, $metric);
        return $response;
    }

    /**
     * Operation companyBasicFinancialsWithHttpInfo
     *
     * Basic Financials
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $metric Metric type. Can be 1 of the following values &lt;code&gt;all&lt;/code&gt; (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\BasicFinancials, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyBasicFinancialsWithHttpInfo($symbol, $metric)
    {
        $request = $this->companyBasicFinancialsRequest($symbol, $metric);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\BasicFinancials' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\BasicFinancials', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\BasicFinancials';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\BasicFinancials',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyBasicFinancialsAsync
     *
     * Basic Financials
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $metric Metric type. Can be 1 of the following values &lt;code&gt;all&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyBasicFinancialsAsync($symbol, $metric)
    {
        return $this->companyBasicFinancialsAsyncWithHttpInfo($symbol, $metric)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyBasicFinancialsAsyncWithHttpInfo
     *
     * Basic Financials
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $metric Metric type. Can be 1 of the following values &lt;code&gt;all&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyBasicFinancialsAsyncWithHttpInfo($symbol, $metric)
    {
        $returnType = '\Finnhub\Model\BasicFinancials';
        $request = $this->companyBasicFinancialsRequest($symbol, $metric);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyBasicFinancials'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $metric Metric type. Can be 1 of the following values &lt;code&gt;all&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyBasicFinancialsRequest($symbol, $metric)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyBasicFinancials'
            );
        }
        // verify the required parameter 'metric' is set
        if ($metric === null || (is_array($metric) && count($metric) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $metric when calling companyBasicFinancials'
            );
        }

        $resourcePath = '/stock/metric';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($metric)) {
            $metric = ObjectSerializer::serializeCollection($metric, '', true);
        }
        if ($metric !== null) {
            $queryParams['metric'] = $metric;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyEarnings
     *
     * Earnings Surprises
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of period returned. Leave blank to get the full history. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EarningResult[]
     */
    public function companyEarnings($symbol, $limit = null)
    {
        list($response) = $this->companyEarningsWithHttpInfo($symbol, $limit);
        return $response;
    }

    /**
     * Operation companyEarningsWithHttpInfo
     *
     * Earnings Surprises
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of period returned. Leave blank to get the full history. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EarningResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function companyEarningsWithHttpInfo($symbol, $limit = null)
    {
        $request = $this->companyEarningsRequest($symbol, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EarningResult[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EarningResult[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EarningResult[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EarningResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyEarningsAsync
     *
     * Earnings Surprises
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of period returned. Leave blank to get the full history. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEarningsAsync($symbol, $limit = null)
    {
        return $this->companyEarningsAsyncWithHttpInfo($symbol, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyEarningsAsyncWithHttpInfo
     *
     * Earnings Surprises
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of period returned. Leave blank to get the full history. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEarningsAsyncWithHttpInfo($symbol, $limit = null)
    {
        $returnType = '\Finnhub\Model\EarningResult[]';
        $request = $this->companyEarningsRequest($symbol, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyEarnings'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of period returned. Leave blank to get the full history. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyEarningsRequest($symbol, $limit = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyEarnings'
            );
        }

        $resourcePath = '/stock/earnings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyEarningsQualityScore
     *
     * Company Earnings Quality Score
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $freq Frequency. Currently support &lt;code&gt;annual&lt;/code&gt; and &lt;code&gt;quarterly&lt;/code&gt; (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CompanyEarningsQualityScore
     */
    public function companyEarningsQualityScore($symbol, $freq)
    {
        list($response) = $this->companyEarningsQualityScoreWithHttpInfo($symbol, $freq);
        return $response;
    }

    /**
     * Operation companyEarningsQualityScoreWithHttpInfo
     *
     * Company Earnings Quality Score
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $freq Frequency. Currently support &lt;code&gt;annual&lt;/code&gt; and &lt;code&gt;quarterly&lt;/code&gt; (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CompanyEarningsQualityScore, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyEarningsQualityScoreWithHttpInfo($symbol, $freq)
    {
        $request = $this->companyEarningsQualityScoreRequest($symbol, $freq);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CompanyEarningsQualityScore' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CompanyEarningsQualityScore', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CompanyEarningsQualityScore';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CompanyEarningsQualityScore',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyEarningsQualityScoreAsync
     *
     * Company Earnings Quality Score
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $freq Frequency. Currently support &lt;code&gt;annual&lt;/code&gt; and &lt;code&gt;quarterly&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEarningsQualityScoreAsync($symbol, $freq)
    {
        return $this->companyEarningsQualityScoreAsyncWithHttpInfo($symbol, $freq)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyEarningsQualityScoreAsyncWithHttpInfo
     *
     * Company Earnings Quality Score
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $freq Frequency. Currently support &lt;code&gt;annual&lt;/code&gt; and &lt;code&gt;quarterly&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEarningsQualityScoreAsyncWithHttpInfo($symbol, $freq)
    {
        $returnType = '\Finnhub\Model\CompanyEarningsQualityScore';
        $request = $this->companyEarningsQualityScoreRequest($symbol, $freq);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyEarningsQualityScore'
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $freq Frequency. Currently support &lt;code&gt;annual&lt;/code&gt; and &lt;code&gt;quarterly&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyEarningsQualityScoreRequest($symbol, $freq)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyEarningsQualityScore'
            );
        }
        // verify the required parameter 'freq' is set
        if ($freq === null || (is_array($freq) && count($freq) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $freq when calling companyEarningsQualityScore'
            );
        }

        $resourcePath = '/stock/earnings-quality-score';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($freq)) {
            $freq = ObjectSerializer::serializeCollection($freq, '', true);
        }
        if ($freq !== null) {
            $queryParams['freq'] = $freq;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyEbitEstimates
     *
     * EBIT Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EbitEstimates
     */
    public function companyEbitEstimates($symbol, $freq = null)
    {
        list($response) = $this->companyEbitEstimatesWithHttpInfo($symbol, $freq);
        return $response;
    }

    /**
     * Operation companyEbitEstimatesWithHttpInfo
     *
     * EBIT Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EbitEstimates, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyEbitEstimatesWithHttpInfo($symbol, $freq = null)
    {
        $request = $this->companyEbitEstimatesRequest($symbol, $freq);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EbitEstimates' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EbitEstimates', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EbitEstimates';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EbitEstimates',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyEbitEstimatesAsync
     *
     * EBIT Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEbitEstimatesAsync($symbol, $freq = null)
    {
        return $this->companyEbitEstimatesAsyncWithHttpInfo($symbol, $freq)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyEbitEstimatesAsyncWithHttpInfo
     *
     * EBIT Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEbitEstimatesAsyncWithHttpInfo($symbol, $freq = null)
    {
        $returnType = '\Finnhub\Model\EbitEstimates';
        $request = $this->companyEbitEstimatesRequest($symbol, $freq);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyEbitEstimates'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyEbitEstimatesRequest($symbol, $freq = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyEbitEstimates'
            );
        }

        $resourcePath = '/stock/ebit-estimate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($freq)) {
            $freq = ObjectSerializer::serializeCollection($freq, '', true);
        }
        if ($freq !== null) {
            $queryParams['freq'] = $freq;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyEbitdaEstimates
     *
     * EBITDA Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EbitdaEstimates
     */
    public function companyEbitdaEstimates($symbol, $freq = null)
    {
        list($response) = $this->companyEbitdaEstimatesWithHttpInfo($symbol, $freq);
        return $response;
    }

    /**
     * Operation companyEbitdaEstimatesWithHttpInfo
     *
     * EBITDA Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EbitdaEstimates, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyEbitdaEstimatesWithHttpInfo($symbol, $freq = null)
    {
        $request = $this->companyEbitdaEstimatesRequest($symbol, $freq);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EbitdaEstimates' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EbitdaEstimates', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EbitdaEstimates';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EbitdaEstimates',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyEbitdaEstimatesAsync
     *
     * EBITDA Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEbitdaEstimatesAsync($symbol, $freq = null)
    {
        return $this->companyEbitdaEstimatesAsyncWithHttpInfo($symbol, $freq)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyEbitdaEstimatesAsyncWithHttpInfo
     *
     * EBITDA Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEbitdaEstimatesAsyncWithHttpInfo($symbol, $freq = null)
    {
        $returnType = '\Finnhub\Model\EbitdaEstimates';
        $request = $this->companyEbitdaEstimatesRequest($symbol, $freq);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyEbitdaEstimates'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyEbitdaEstimatesRequest($symbol, $freq = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyEbitdaEstimates'
            );
        }

        $resourcePath = '/stock/ebitda-estimate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($freq)) {
            $freq = ObjectSerializer::serializeCollection($freq, '', true);
        }
        if ($freq !== null) {
            $queryParams['freq'] = $freq;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyEpsEstimates
     *
     * Earnings Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EarningsEstimates
     */
    public function companyEpsEstimates($symbol, $freq = null)
    {
        list($response) = $this->companyEpsEstimatesWithHttpInfo($symbol, $freq);
        return $response;
    }

    /**
     * Operation companyEpsEstimatesWithHttpInfo
     *
     * Earnings Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EarningsEstimates, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyEpsEstimatesWithHttpInfo($symbol, $freq = null)
    {
        $request = $this->companyEpsEstimatesRequest($symbol, $freq);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EarningsEstimates' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EarningsEstimates', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EarningsEstimates';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EarningsEstimates',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyEpsEstimatesAsync
     *
     * Earnings Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEpsEstimatesAsync($symbol, $freq = null)
    {
        return $this->companyEpsEstimatesAsyncWithHttpInfo($symbol, $freq)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyEpsEstimatesAsyncWithHttpInfo
     *
     * Earnings Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEpsEstimatesAsyncWithHttpInfo($symbol, $freq = null)
    {
        $returnType = '\Finnhub\Model\EarningsEstimates';
        $request = $this->companyEpsEstimatesRequest($symbol, $freq);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyEpsEstimates'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyEpsEstimatesRequest($symbol, $freq = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyEpsEstimates'
            );
        }

        $resourcePath = '/stock/eps-estimate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($freq)) {
            $freq = ObjectSerializer::serializeCollection($freq, '', true);
        }
        if ($freq !== null) {
            $queryParams['freq'] = $freq;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyEsgScore
     *
     * Company ESG Scores
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CompanyESG
     */
    public function companyEsgScore($symbol)
    {
        list($response) = $this->companyEsgScoreWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation companyEsgScoreWithHttpInfo
     *
     * Company ESG Scores
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CompanyESG, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyEsgScoreWithHttpInfo($symbol)
    {
        $request = $this->companyEsgScoreRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CompanyESG' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CompanyESG', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CompanyESG';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CompanyESG',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyEsgScoreAsync
     *
     * Company ESG Scores
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEsgScoreAsync($symbol)
    {
        return $this->companyEsgScoreAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyEsgScoreAsyncWithHttpInfo
     *
     * Company ESG Scores
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEsgScoreAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\CompanyESG';
        $request = $this->companyEsgScoreRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyEsgScore'
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyEsgScoreRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyEsgScore'
            );
        }

        $resourcePath = '/stock/esg';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyExecutive
     *
     * Company Executive
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CompanyExecutive
     */
    public function companyExecutive($symbol)
    {
        list($response) = $this->companyExecutiveWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation companyExecutiveWithHttpInfo
     *
     * Company Executive
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CompanyExecutive, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyExecutiveWithHttpInfo($symbol)
    {
        $request = $this->companyExecutiveRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CompanyExecutive' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CompanyExecutive', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CompanyExecutive';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CompanyExecutive',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyExecutiveAsync
     *
     * Company Executive
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyExecutiveAsync($symbol)
    {
        return $this->companyExecutiveAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyExecutiveAsyncWithHttpInfo
     *
     * Company Executive
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyExecutiveAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\CompanyExecutive';
        $request = $this->companyExecutiveRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyExecutive'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyExecutiveRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyExecutive'
            );
        }

        $resourcePath = '/stock/executive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyNews
     *
     * Company News
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CompanyNews[]
     */
    public function companyNews($symbol, $from, $to)
    {
        list($response) = $this->companyNewsWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation companyNewsWithHttpInfo
     *
     * Company News
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CompanyNews[], HTTP status code, HTTP response headers (array of strings)
     */
    public function companyNewsWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->companyNewsRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CompanyNews[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CompanyNews[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CompanyNews[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CompanyNews[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyNewsAsync
     *
     * Company News
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyNewsAsync($symbol, $from, $to)
    {
        return $this->companyNewsAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyNewsAsyncWithHttpInfo
     *
     * Company News
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyNewsAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\CompanyNews[]';
        $request = $this->companyNewsRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyNews'
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyNewsRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyNews'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling companyNews'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling companyNews'
            );
        }

        $resourcePath = '/company-news';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyPeers
     *
     * Peers
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $grouping Specify the grouping criteria for choosing peers.Supporter values: &lt;code&gt;sector&lt;/code&gt;, &lt;code&gt;industry&lt;/code&gt;, &lt;code&gt;subIndustry&lt;/code&gt;. Default to &lt;code&gt;subIndustry&lt;/code&gt;. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function companyPeers($symbol, $grouping = null)
    {
        list($response) = $this->companyPeersWithHttpInfo($symbol, $grouping);
        return $response;
    }

    /**
     * Operation companyPeersWithHttpInfo
     *
     * Peers
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $grouping Specify the grouping criteria for choosing peers.Supporter values: &lt;code&gt;sector&lt;/code&gt;, &lt;code&gt;industry&lt;/code&gt;, &lt;code&gt;subIndustry&lt;/code&gt;. Default to &lt;code&gt;subIndustry&lt;/code&gt;. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function companyPeersWithHttpInfo($symbol, $grouping = null)
    {
        $request = $this->companyPeersRequest($symbol, $grouping);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyPeersAsync
     *
     * Peers
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $grouping Specify the grouping criteria for choosing peers.Supporter values: &lt;code&gt;sector&lt;/code&gt;, &lt;code&gt;industry&lt;/code&gt;, &lt;code&gt;subIndustry&lt;/code&gt;. Default to &lt;code&gt;subIndustry&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyPeersAsync($symbol, $grouping = null)
    {
        return $this->companyPeersAsyncWithHttpInfo($symbol, $grouping)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyPeersAsyncWithHttpInfo
     *
     * Peers
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $grouping Specify the grouping criteria for choosing peers.Supporter values: &lt;code&gt;sector&lt;/code&gt;, &lt;code&gt;industry&lt;/code&gt;, &lt;code&gt;subIndustry&lt;/code&gt;. Default to &lt;code&gt;subIndustry&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyPeersAsyncWithHttpInfo($symbol, $grouping = null)
    {
        $returnType = 'string[]';
        $request = $this->companyPeersRequest($symbol, $grouping);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyPeers'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $grouping Specify the grouping criteria for choosing peers.Supporter values: &lt;code&gt;sector&lt;/code&gt;, &lt;code&gt;industry&lt;/code&gt;, &lt;code&gt;subIndustry&lt;/code&gt;. Default to &lt;code&gt;subIndustry&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyPeersRequest($symbol, $grouping = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyPeers'
            );
        }

        $resourcePath = '/stock/peers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($grouping)) {
            $grouping = ObjectSerializer::serializeCollection($grouping, '', true);
        }
        if ($grouping !== null) {
            $queryParams['grouping'] = $grouping;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyProfile
     *
     * Company Profile
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CompanyProfile
     */
    public function companyProfile($symbol = null, $isin = null, $cusip = null)
    {
        list($response) = $this->companyProfileWithHttpInfo($symbol, $isin, $cusip);
        return $response;
    }

    /**
     * Operation companyProfileWithHttpInfo
     *
     * Company Profile
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CompanyProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyProfileWithHttpInfo($symbol = null, $isin = null, $cusip = null)
    {
        $request = $this->companyProfileRequest($symbol, $isin, $cusip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CompanyProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CompanyProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CompanyProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CompanyProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyProfileAsync
     *
     * Company Profile
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyProfileAsync($symbol = null, $isin = null, $cusip = null)
    {
        return $this->companyProfileAsyncWithHttpInfo($symbol, $isin, $cusip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyProfileAsyncWithHttpInfo
     *
     * Company Profile
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyProfileAsyncWithHttpInfo($symbol = null, $isin = null, $cusip = null)
    {
        $returnType = '\Finnhub\Model\CompanyProfile';
        $request = $this->companyProfileRequest($symbol, $isin, $cusip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyProfile'
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyProfileRequest($symbol = null, $isin = null, $cusip = null)
    {

        $resourcePath = '/stock/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }
        // query params
        if (is_array($cusip)) {
            $cusip = ObjectSerializer::serializeCollection($cusip, '', true);
        }
        if ($cusip !== null) {
            $queryParams['cusip'] = $cusip;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyProfile2
     *
     * Company Profile 2
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CompanyProfile2
     */
    public function companyProfile2($symbol = null, $isin = null, $cusip = null)
    {
        list($response) = $this->companyProfile2WithHttpInfo($symbol, $isin, $cusip);
        return $response;
    }

    /**
     * Operation companyProfile2WithHttpInfo
     *
     * Company Profile 2
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CompanyProfile2, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyProfile2WithHttpInfo($symbol = null, $isin = null, $cusip = null)
    {
        $request = $this->companyProfile2Request($symbol, $isin, $cusip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CompanyProfile2' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CompanyProfile2', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CompanyProfile2';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CompanyProfile2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyProfile2Async
     *
     * Company Profile 2
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyProfile2Async($symbol = null, $isin = null, $cusip = null)
    {
        return $this->companyProfile2AsyncWithHttpInfo($symbol, $isin, $cusip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyProfile2AsyncWithHttpInfo
     *
     * Company Profile 2
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyProfile2AsyncWithHttpInfo($symbol = null, $isin = null, $cusip = null)
    {
        $returnType = '\Finnhub\Model\CompanyProfile2';
        $request = $this->companyProfile2Request($symbol, $isin, $cusip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyProfile2'
     *
     * @param  string $symbol Symbol of the company: AAPL e.g. (optional)
     * @param  string $isin ISIN (optional)
     * @param  string $cusip CUSIP (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyProfile2Request($symbol = null, $isin = null, $cusip = null)
    {

        $resourcePath = '/stock/profile2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }
        // query params
        if (is_array($cusip)) {
            $cusip = ObjectSerializer::serializeCollection($cusip, '', true);
        }
        if ($cusip !== null) {
            $queryParams['cusip'] = $cusip;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyRevenueEstimates
     *
     * Revenue Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\RevenueEstimates
     */
    public function companyRevenueEstimates($symbol, $freq = null)
    {
        list($response) = $this->companyRevenueEstimatesWithHttpInfo($symbol, $freq);
        return $response;
    }

    /**
     * Operation companyRevenueEstimatesWithHttpInfo
     *
     * Revenue Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\RevenueEstimates, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyRevenueEstimatesWithHttpInfo($symbol, $freq = null)
    {
        $request = $this->companyRevenueEstimatesRequest($symbol, $freq);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\RevenueEstimates' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\RevenueEstimates', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\RevenueEstimates';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\RevenueEstimates',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyRevenueEstimatesAsync
     *
     * Revenue Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyRevenueEstimatesAsync($symbol, $freq = null)
    {
        return $this->companyRevenueEstimatesAsyncWithHttpInfo($symbol, $freq)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyRevenueEstimatesAsyncWithHttpInfo
     *
     * Revenue Estimates
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyRevenueEstimatesAsyncWithHttpInfo($symbol, $freq = null)
    {
        $returnType = '\Finnhub\Model\RevenueEstimates';
        $request = $this->companyRevenueEstimatesRequest($symbol, $freq);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyRevenueEstimates'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $freq Can take 1 of the following values: &lt;code&gt;annual, quarterly&lt;/code&gt;. Default to &lt;code&gt;quarterly&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyRevenueEstimatesRequest($symbol, $freq = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling companyRevenueEstimates'
            );
        }

        $resourcePath = '/stock/revenue-estimate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($freq)) {
            $freq = ObjectSerializer::serializeCollection($freq, '', true);
        }
        if ($freq !== null) {
            $queryParams['freq'] = $freq;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation congressionalTrading
     *
     * Congressional Trading
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CongressionalTrading
     */
    public function congressionalTrading($symbol, $from, $to)
    {
        list($response) = $this->congressionalTradingWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation congressionalTradingWithHttpInfo
     *
     * Congressional Trading
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CongressionalTrading, HTTP status code, HTTP response headers (array of strings)
     */
    public function congressionalTradingWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->congressionalTradingRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CongressionalTrading' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CongressionalTrading', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CongressionalTrading';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CongressionalTrading',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation congressionalTradingAsync
     *
     * Congressional Trading
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function congressionalTradingAsync($symbol, $from, $to)
    {
        return $this->congressionalTradingAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation congressionalTradingAsyncWithHttpInfo
     *
     * Congressional Trading
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function congressionalTradingAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\CongressionalTrading';
        $request = $this->congressionalTradingRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'congressionalTrading'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function congressionalTradingRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling congressionalTrading'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling congressionalTrading'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling congressionalTrading'
            );
        }

        $resourcePath = '/stock/congressional-trading';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation country
     *
     * Country Metadata
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CountryMetadata[]
     */
    public function country()
    {
        list($response) = $this->countryWithHttpInfo();
        return $response;
    }

    /**
     * Operation countryWithHttpInfo
     *
     * Country Metadata
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CountryMetadata[], HTTP status code, HTTP response headers (array of strings)
     */
    public function countryWithHttpInfo()
    {
        $request = $this->countryRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CountryMetadata[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CountryMetadata[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CountryMetadata[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CountryMetadata[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation countryAsync
     *
     * Country Metadata
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryAsync()
    {
        return $this->countryAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation countryAsyncWithHttpInfo
     *
     * Country Metadata
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryAsyncWithHttpInfo()
    {
        $returnType = '\Finnhub\Model\CountryMetadata[]';
        $request = $this->countryRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'country'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function countryRequest()
    {

        $resourcePath = '/country';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation covid19
     *
     * COVID-19
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CovidInfo[]
     */
    public function covid19()
    {
        list($response) = $this->covid19WithHttpInfo();
        return $response;
    }

    /**
     * Operation covid19WithHttpInfo
     *
     * COVID-19
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CovidInfo[], HTTP status code, HTTP response headers (array of strings)
     */
    public function covid19WithHttpInfo()
    {
        $request = $this->covid19Request();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CovidInfo[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CovidInfo[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CovidInfo[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CovidInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation covid19Async
     *
     * COVID-19
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function covid19Async()
    {
        return $this->covid19AsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation covid19AsyncWithHttpInfo
     *
     * COVID-19
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function covid19AsyncWithHttpInfo()
    {
        $returnType = '\Finnhub\Model\CovidInfo[]';
        $request = $this->covid19Request();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'covid19'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function covid19Request()
    {

        $resourcePath = '/covid19/us';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cryptoCandles
     *
     * Crypto Candles
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/crypto/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CryptoCandles
     */
    public function cryptoCandles($symbol, $resolution, $from, $to)
    {
        list($response) = $this->cryptoCandlesWithHttpInfo($symbol, $resolution, $from, $to);
        return $response;
    }

    /**
     * Operation cryptoCandlesWithHttpInfo
     *
     * Crypto Candles
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/crypto/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CryptoCandles, HTTP status code, HTTP response headers (array of strings)
     */
    public function cryptoCandlesWithHttpInfo($symbol, $resolution, $from, $to)
    {
        $request = $this->cryptoCandlesRequest($symbol, $resolution, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CryptoCandles' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CryptoCandles', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CryptoCandles';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CryptoCandles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cryptoCandlesAsync
     *
     * Crypto Candles
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/crypto/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoCandlesAsync($symbol, $resolution, $from, $to)
    {
        return $this->cryptoCandlesAsyncWithHttpInfo($symbol, $resolution, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cryptoCandlesAsyncWithHttpInfo
     *
     * Crypto Candles
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/crypto/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoCandlesAsyncWithHttpInfo($symbol, $resolution, $from, $to)
    {
        $returnType = '\Finnhub\Model\CryptoCandles';
        $request = $this->cryptoCandlesRequest($symbol, $resolution, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cryptoCandles'
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/crypto/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cryptoCandlesRequest($symbol, $resolution, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cryptoCandles'
            );
        }
        // verify the required parameter 'resolution' is set
        if ($resolution === null || (is_array($resolution) && count($resolution) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resolution when calling cryptoCandles'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling cryptoCandles'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling cryptoCandles'
            );
        }

        $resourcePath = '/crypto/candle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($resolution)) {
            $resolution = ObjectSerializer::serializeCollection($resolution, '', true);
        }
        if ($resolution !== null) {
            $queryParams['resolution'] = $resolution;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cryptoExchanges
     *
     * Crypto Exchanges
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function cryptoExchanges()
    {
        list($response) = $this->cryptoExchangesWithHttpInfo();
        return $response;
    }

    /**
     * Operation cryptoExchangesWithHttpInfo
     *
     * Crypto Exchanges
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cryptoExchangesWithHttpInfo()
    {
        $request = $this->cryptoExchangesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cryptoExchangesAsync
     *
     * Crypto Exchanges
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoExchangesAsync()
    {
        return $this->cryptoExchangesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cryptoExchangesAsyncWithHttpInfo
     *
     * Crypto Exchanges
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoExchangesAsyncWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->cryptoExchangesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cryptoExchanges'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cryptoExchangesRequest()
    {

        $resourcePath = '/crypto/exchange';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cryptoProfile
     *
     * Crypto Profile
     *
     * @param  string $symbol Crypto symbol such as BTC or ETH. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CryptoProfile
     */
    public function cryptoProfile($symbol)
    {
        list($response) = $this->cryptoProfileWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation cryptoProfileWithHttpInfo
     *
     * Crypto Profile
     *
     * @param  string $symbol Crypto symbol such as BTC or ETH. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CryptoProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function cryptoProfileWithHttpInfo($symbol)
    {
        $request = $this->cryptoProfileRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CryptoProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CryptoProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CryptoProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CryptoProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cryptoProfileAsync
     *
     * Crypto Profile
     *
     * @param  string $symbol Crypto symbol such as BTC or ETH. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoProfileAsync($symbol)
    {
        return $this->cryptoProfileAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cryptoProfileAsyncWithHttpInfo
     *
     * Crypto Profile
     *
     * @param  string $symbol Crypto symbol such as BTC or ETH. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoProfileAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\CryptoProfile';
        $request = $this->cryptoProfileRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cryptoProfile'
     *
     * @param  string $symbol Crypto symbol such as BTC or ETH. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cryptoProfileRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cryptoProfile'
            );
        }

        $resourcePath = '/crypto/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cryptoSymbols
     *
     * Crypto Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\CryptoSymbol[]
     */
    public function cryptoSymbols($exchange)
    {
        list($response) = $this->cryptoSymbolsWithHttpInfo($exchange);
        return $response;
    }

    /**
     * Operation cryptoSymbolsWithHttpInfo
     *
     * Crypto Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\CryptoSymbol[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cryptoSymbolsWithHttpInfo($exchange)
    {
        $request = $this->cryptoSymbolsRequest($exchange);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\CryptoSymbol[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\CryptoSymbol[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\CryptoSymbol[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\CryptoSymbol[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cryptoSymbolsAsync
     *
     * Crypto Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoSymbolsAsync($exchange)
    {
        return $this->cryptoSymbolsAsyncWithHttpInfo($exchange)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cryptoSymbolsAsyncWithHttpInfo
     *
     * Crypto Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cryptoSymbolsAsyncWithHttpInfo($exchange)
    {
        $returnType = '\Finnhub\Model\CryptoSymbol[]';
        $request = $this->cryptoSymbolsRequest($exchange);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cryptoSymbols'
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cryptoSymbolsRequest($exchange)
    {
        // verify the required parameter 'exchange' is set
        if ($exchange === null || (is_array($exchange) && count($exchange) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange when calling cryptoSymbols'
            );
        }

        $resourcePath = '/crypto/symbol';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($exchange)) {
            $exchange = ObjectSerializer::serializeCollection($exchange, '', true);
        }
        if ($exchange !== null) {
            $queryParams['exchange'] = $exchange;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation earningsCalendar
     *
     * Earnings Calendar
     *
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     * @param  string $symbol Filter by symbol: AAPL. (optional)
     * @param  bool $international Set to &lt;code&gt;true&lt;/code&gt; to include international markets. Default value is &lt;code&gt;false&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EarningsCalendar
     */
    public function earningsCalendar($from = null, $to = null, $symbol = null, $international = null)
    {
        list($response) = $this->earningsCalendarWithHttpInfo($from, $to, $symbol, $international);
        return $response;
    }

    /**
     * Operation earningsCalendarWithHttpInfo
     *
     * Earnings Calendar
     *
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     * @param  string $symbol Filter by symbol: AAPL. (optional)
     * @param  bool $international Set to &lt;code&gt;true&lt;/code&gt; to include international markets. Default value is &lt;code&gt;false&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EarningsCalendar, HTTP status code, HTTP response headers (array of strings)
     */
    public function earningsCalendarWithHttpInfo($from = null, $to = null, $symbol = null, $international = null)
    {
        $request = $this->earningsCalendarRequest($from, $to, $symbol, $international);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EarningsCalendar' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EarningsCalendar', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EarningsCalendar';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EarningsCalendar',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation earningsCalendarAsync
     *
     * Earnings Calendar
     *
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     * @param  string $symbol Filter by symbol: AAPL. (optional)
     * @param  bool $international Set to &lt;code&gt;true&lt;/code&gt; to include international markets. Default value is &lt;code&gt;false&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function earningsCalendarAsync($from = null, $to = null, $symbol = null, $international = null)
    {
        return $this->earningsCalendarAsyncWithHttpInfo($from, $to, $symbol, $international)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation earningsCalendarAsyncWithHttpInfo
     *
     * Earnings Calendar
     *
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     * @param  string $symbol Filter by symbol: AAPL. (optional)
     * @param  bool $international Set to &lt;code&gt;true&lt;/code&gt; to include international markets. Default value is &lt;code&gt;false&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function earningsCalendarAsyncWithHttpInfo($from = null, $to = null, $symbol = null, $international = null)
    {
        $returnType = '\Finnhub\Model\EarningsCalendar';
        $request = $this->earningsCalendarRequest($from, $to, $symbol, $international);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'earningsCalendar'
     *
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     * @param  string $symbol Filter by symbol: AAPL. (optional)
     * @param  bool $international Set to &lt;code&gt;true&lt;/code&gt; to include international markets. Default value is &lt;code&gt;false&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function earningsCalendarRequest($from = null, $to = null, $symbol = null, $international = null)
    {

        $resourcePath = '/calendar/earnings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }
        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($international)) {
            $international = ObjectSerializer::serializeCollection($international, '', true);
        }
        if ($international !== null) {
            $queryParams['international'] = $international;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation economicCalendar
     *
     * Economic Calendar
     *
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EconomicCalendar
     */
    public function economicCalendar($from = null, $to = null)
    {
        list($response) = $this->economicCalendarWithHttpInfo($from, $to);
        return $response;
    }

    /**
     * Operation economicCalendarWithHttpInfo
     *
     * Economic Calendar
     *
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EconomicCalendar, HTTP status code, HTTP response headers (array of strings)
     */
    public function economicCalendarWithHttpInfo($from = null, $to = null)
    {
        $request = $this->economicCalendarRequest($from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EconomicCalendar' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EconomicCalendar', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EconomicCalendar';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EconomicCalendar',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation economicCalendarAsync
     *
     * Economic Calendar
     *
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function economicCalendarAsync($from = null, $to = null)
    {
        return $this->economicCalendarAsyncWithHttpInfo($from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation economicCalendarAsyncWithHttpInfo
     *
     * Economic Calendar
     *
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function economicCalendarAsyncWithHttpInfo($from = null, $to = null)
    {
        $returnType = '\Finnhub\Model\EconomicCalendar';
        $request = $this->economicCalendarRequest($from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'economicCalendar'
     *
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function economicCalendarRequest($from = null, $to = null)
    {

        $resourcePath = '/calendar/economic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation economicCode
     *
     * Economic Code
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EconomicCode[]
     */
    public function economicCode()
    {
        list($response) = $this->economicCodeWithHttpInfo();
        return $response;
    }

    /**
     * Operation economicCodeWithHttpInfo
     *
     * Economic Code
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EconomicCode[], HTTP status code, HTTP response headers (array of strings)
     */
    public function economicCodeWithHttpInfo()
    {
        $request = $this->economicCodeRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EconomicCode[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EconomicCode[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EconomicCode[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EconomicCode[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation economicCodeAsync
     *
     * Economic Code
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function economicCodeAsync()
    {
        return $this->economicCodeAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation economicCodeAsyncWithHttpInfo
     *
     * Economic Code
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function economicCodeAsyncWithHttpInfo()
    {
        $returnType = '\Finnhub\Model\EconomicCode[]';
        $request = $this->economicCodeRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'economicCode'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function economicCodeRequest()
    {

        $resourcePath = '/economic/code';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation economicData
     *
     * Economic Data
     *
     * @param  string $code Economic code. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EconomicData
     */
    public function economicData($code)
    {
        list($response) = $this->economicDataWithHttpInfo($code);
        return $response;
    }

    /**
     * Operation economicDataWithHttpInfo
     *
     * Economic Data
     *
     * @param  string $code Economic code. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EconomicData, HTTP status code, HTTP response headers (array of strings)
     */
    public function economicDataWithHttpInfo($code)
    {
        $request = $this->economicDataRequest($code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EconomicData' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EconomicData', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EconomicData';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EconomicData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation economicDataAsync
     *
     * Economic Data
     *
     * @param  string $code Economic code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function economicDataAsync($code)
    {
        return $this->economicDataAsyncWithHttpInfo($code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation economicDataAsyncWithHttpInfo
     *
     * Economic Data
     *
     * @param  string $code Economic code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function economicDataAsyncWithHttpInfo($code)
    {
        $returnType = '\Finnhub\Model\EconomicData';
        $request = $this->economicDataRequest($code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'economicData'
     *
     * @param  string $code Economic code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function economicDataRequest($code)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling economicData'
            );
        }

        $resourcePath = '/economic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($code)) {
            $code = ObjectSerializer::serializeCollection($code, '', true);
        }
        if ($code !== null) {
            $queryParams['code'] = $code;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation etfsCountryExposure
     *
     * ETFs Country Exposure
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\ETFsCountryExposure
     */
    public function etfsCountryExposure($symbol = null, $isin = null)
    {
        list($response) = $this->etfsCountryExposureWithHttpInfo($symbol, $isin);
        return $response;
    }

    /**
     * Operation etfsCountryExposureWithHttpInfo
     *
     * ETFs Country Exposure
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\ETFsCountryExposure, HTTP status code, HTTP response headers (array of strings)
     */
    public function etfsCountryExposureWithHttpInfo($symbol = null, $isin = null)
    {
        $request = $this->etfsCountryExposureRequest($symbol, $isin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\ETFsCountryExposure' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\ETFsCountryExposure', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\ETFsCountryExposure';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\ETFsCountryExposure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation etfsCountryExposureAsync
     *
     * ETFs Country Exposure
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function etfsCountryExposureAsync($symbol = null, $isin = null)
    {
        return $this->etfsCountryExposureAsyncWithHttpInfo($symbol, $isin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation etfsCountryExposureAsyncWithHttpInfo
     *
     * ETFs Country Exposure
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function etfsCountryExposureAsyncWithHttpInfo($symbol = null, $isin = null)
    {
        $returnType = '\Finnhub\Model\ETFsCountryExposure';
        $request = $this->etfsCountryExposureRequest($symbol, $isin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'etfsCountryExposure'
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function etfsCountryExposureRequest($symbol = null, $isin = null)
    {

        $resourcePath = '/etf/country';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation etfsHoldings
     *
     * ETFs Holdings
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     * @param  string $date Query holdings by date. You can use either this param or &lt;code&gt;skip&lt;/code&gt; param, not both. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\ETFsHoldings
     */
    public function etfsHoldings($symbol = null, $isin = null, $skip = null, $date = null)
    {
        list($response) = $this->etfsHoldingsWithHttpInfo($symbol, $isin, $skip, $date);
        return $response;
    }

    /**
     * Operation etfsHoldingsWithHttpInfo
     *
     * ETFs Holdings
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     * @param  string $date Query holdings by date. You can use either this param or &lt;code&gt;skip&lt;/code&gt; param, not both. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\ETFsHoldings, HTTP status code, HTTP response headers (array of strings)
     */
    public function etfsHoldingsWithHttpInfo($symbol = null, $isin = null, $skip = null, $date = null)
    {
        $request = $this->etfsHoldingsRequest($symbol, $isin, $skip, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\ETFsHoldings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\ETFsHoldings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\ETFsHoldings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\ETFsHoldings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation etfsHoldingsAsync
     *
     * ETFs Holdings
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     * @param  string $date Query holdings by date. You can use either this param or &lt;code&gt;skip&lt;/code&gt; param, not both. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function etfsHoldingsAsync($symbol = null, $isin = null, $skip = null, $date = null)
    {
        return $this->etfsHoldingsAsyncWithHttpInfo($symbol, $isin, $skip, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation etfsHoldingsAsyncWithHttpInfo
     *
     * ETFs Holdings
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     * @param  string $date Query holdings by date. You can use either this param or &lt;code&gt;skip&lt;/code&gt; param, not both. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function etfsHoldingsAsyncWithHttpInfo($symbol = null, $isin = null, $skip = null, $date = null)
    {
        $returnType = '\Finnhub\Model\ETFsHoldings';
        $request = $this->etfsHoldingsRequest($symbol, $isin, $skip, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'etfsHoldings'
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     * @param  string $date Query holdings by date. You can use either this param or &lt;code&gt;skip&lt;/code&gt; param, not both. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function etfsHoldingsRequest($symbol = null, $isin = null, $skip = null, $date = null)
    {

        $resourcePath = '/etf/holdings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }
        // query params
        if (is_array($skip)) {
            $skip = ObjectSerializer::serializeCollection($skip, '', true);
        }
        if ($skip !== null) {
            $queryParams['skip'] = $skip;
        }
        // query params
        if (is_array($date)) {
            $date = ObjectSerializer::serializeCollection($date, '', true);
        }
        if ($date !== null) {
            $queryParams['date'] = $date;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation etfsProfile
     *
     * ETFs Profile
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\ETFsProfile
     */
    public function etfsProfile($symbol = null, $isin = null)
    {
        list($response) = $this->etfsProfileWithHttpInfo($symbol, $isin);
        return $response;
    }

    /**
     * Operation etfsProfileWithHttpInfo
     *
     * ETFs Profile
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\ETFsProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function etfsProfileWithHttpInfo($symbol = null, $isin = null)
    {
        $request = $this->etfsProfileRequest($symbol, $isin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\ETFsProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\ETFsProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\ETFsProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\ETFsProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation etfsProfileAsync
     *
     * ETFs Profile
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function etfsProfileAsync($symbol = null, $isin = null)
    {
        return $this->etfsProfileAsyncWithHttpInfo($symbol, $isin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation etfsProfileAsyncWithHttpInfo
     *
     * ETFs Profile
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function etfsProfileAsyncWithHttpInfo($symbol = null, $isin = null)
    {
        $returnType = '\Finnhub\Model\ETFsProfile';
        $request = $this->etfsProfileRequest($symbol, $isin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'etfsProfile'
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function etfsProfileRequest($symbol = null, $isin = null)
    {

        $resourcePath = '/etf/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation etfsSectorExposure
     *
     * ETFs Sector Exposure
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\ETFsSectorExposure
     */
    public function etfsSectorExposure($symbol = null, $isin = null)
    {
        list($response) = $this->etfsSectorExposureWithHttpInfo($symbol, $isin);
        return $response;
    }

    /**
     * Operation etfsSectorExposureWithHttpInfo
     *
     * ETFs Sector Exposure
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\ETFsSectorExposure, HTTP status code, HTTP response headers (array of strings)
     */
    public function etfsSectorExposureWithHttpInfo($symbol = null, $isin = null)
    {
        $request = $this->etfsSectorExposureRequest($symbol, $isin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\ETFsSectorExposure' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\ETFsSectorExposure', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\ETFsSectorExposure';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\ETFsSectorExposure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation etfsSectorExposureAsync
     *
     * ETFs Sector Exposure
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function etfsSectorExposureAsync($symbol = null, $isin = null)
    {
        return $this->etfsSectorExposureAsyncWithHttpInfo($symbol, $isin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation etfsSectorExposureAsyncWithHttpInfo
     *
     * ETFs Sector Exposure
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function etfsSectorExposureAsyncWithHttpInfo($symbol = null, $isin = null)
    {
        $returnType = '\Finnhub\Model\ETFsSectorExposure';
        $request = $this->etfsSectorExposureRequest($symbol, $isin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'etfsSectorExposure'
     *
     * @param  string $symbol ETF symbol. (optional)
     * @param  string $isin ETF isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function etfsSectorExposureRequest($symbol = null, $isin = null)
    {

        $resourcePath = '/etf/sector';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fdaCommitteeMeetingCalendar
     *
     * FDA Committee Meeting Calendar
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\FDAComitteeMeeting[]
     */
    public function fdaCommitteeMeetingCalendar()
    {
        list($response) = $this->fdaCommitteeMeetingCalendarWithHttpInfo();
        return $response;
    }

    /**
     * Operation fdaCommitteeMeetingCalendarWithHttpInfo
     *
     * FDA Committee Meeting Calendar
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\FDAComitteeMeeting[], HTTP status code, HTTP response headers (array of strings)
     */
    public function fdaCommitteeMeetingCalendarWithHttpInfo()
    {
        $request = $this->fdaCommitteeMeetingCalendarRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\FDAComitteeMeeting[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\FDAComitteeMeeting[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\FDAComitteeMeeting[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\FDAComitteeMeeting[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fdaCommitteeMeetingCalendarAsync
     *
     * FDA Committee Meeting Calendar
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fdaCommitteeMeetingCalendarAsync()
    {
        return $this->fdaCommitteeMeetingCalendarAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fdaCommitteeMeetingCalendarAsyncWithHttpInfo
     *
     * FDA Committee Meeting Calendar
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fdaCommitteeMeetingCalendarAsyncWithHttpInfo()
    {
        $returnType = '\Finnhub\Model\FDAComitteeMeeting[]';
        $request = $this->fdaCommitteeMeetingCalendarRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fdaCommitteeMeetingCalendar'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fdaCommitteeMeetingCalendarRequest()
    {

        $resourcePath = '/fda-advisory-committee-calendar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filings
     *
     * SEC Filings
     *
     * @param  string $symbol Symbol. Leave &lt;code&gt;symbol&lt;/code&gt;,&lt;code&gt;cik&lt;/code&gt; and &lt;code&gt;accessNumber&lt;/code&gt; empty to list latest filings. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (optional)
     * @param  string $form Filter by form. You can use this value &lt;code&gt;NT 10-K&lt;/code&gt; to find non-timely filings for a company. (optional)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\Filing[]
     */
    public function filings($symbol = null, $cik = null, $access_number = null, $form = null, $from = null, $to = null)
    {
        list($response) = $this->filingsWithHttpInfo($symbol, $cik, $access_number, $form, $from, $to);
        return $response;
    }

    /**
     * Operation filingsWithHttpInfo
     *
     * SEC Filings
     *
     * @param  string $symbol Symbol. Leave &lt;code&gt;symbol&lt;/code&gt;,&lt;code&gt;cik&lt;/code&gt; and &lt;code&gt;accessNumber&lt;/code&gt; empty to list latest filings. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (optional)
     * @param  string $form Filter by form. You can use this value &lt;code&gt;NT 10-K&lt;/code&gt; to find non-timely filings for a company. (optional)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\Filing[], HTTP status code, HTTP response headers (array of strings)
     */
    public function filingsWithHttpInfo($symbol = null, $cik = null, $access_number = null, $form = null, $from = null, $to = null)
    {
        $request = $this->filingsRequest($symbol, $cik, $access_number, $form, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\Filing[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\Filing[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\Filing[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\Filing[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filingsAsync
     *
     * SEC Filings
     *
     * @param  string $symbol Symbol. Leave &lt;code&gt;symbol&lt;/code&gt;,&lt;code&gt;cik&lt;/code&gt; and &lt;code&gt;accessNumber&lt;/code&gt; empty to list latest filings. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (optional)
     * @param  string $form Filter by form. You can use this value &lt;code&gt;NT 10-K&lt;/code&gt; to find non-timely filings for a company. (optional)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filingsAsync($symbol = null, $cik = null, $access_number = null, $form = null, $from = null, $to = null)
    {
        return $this->filingsAsyncWithHttpInfo($symbol, $cik, $access_number, $form, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filingsAsyncWithHttpInfo
     *
     * SEC Filings
     *
     * @param  string $symbol Symbol. Leave &lt;code&gt;symbol&lt;/code&gt;,&lt;code&gt;cik&lt;/code&gt; and &lt;code&gt;accessNumber&lt;/code&gt; empty to list latest filings. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (optional)
     * @param  string $form Filter by form. You can use this value &lt;code&gt;NT 10-K&lt;/code&gt; to find non-timely filings for a company. (optional)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filingsAsyncWithHttpInfo($symbol = null, $cik = null, $access_number = null, $form = null, $from = null, $to = null)
    {
        $returnType = '\Finnhub\Model\Filing[]';
        $request = $this->filingsRequest($symbol, $cik, $access_number, $form, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filings'
     *
     * @param  string $symbol Symbol. Leave &lt;code&gt;symbol&lt;/code&gt;,&lt;code&gt;cik&lt;/code&gt; and &lt;code&gt;accessNumber&lt;/code&gt; empty to list latest filings. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (optional)
     * @param  string $form Filter by form. You can use this value &lt;code&gt;NT 10-K&lt;/code&gt; to find non-timely filings for a company. (optional)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function filingsRequest($symbol = null, $cik = null, $access_number = null, $form = null, $from = null, $to = null)
    {

        $resourcePath = '/stock/filings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($cik)) {
            $cik = ObjectSerializer::serializeCollection($cik, '', true);
        }
        if ($cik !== null) {
            $queryParams['cik'] = $cik;
        }
        // query params
        if (is_array($access_number)) {
            $access_number = ObjectSerializer::serializeCollection($access_number, '', true);
        }
        if ($access_number !== null) {
            $queryParams['accessNumber'] = $access_number;
        }
        // query params
        if (is_array($form)) {
            $form = ObjectSerializer::serializeCollection($form, '', true);
        }
        if ($form !== null) {
            $queryParams['form'] = $form;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation filingsSentiment
     *
     * SEC Sentiment Analysis
     *
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\SECSentimentAnalysis
     */
    public function filingsSentiment($access_number)
    {
        list($response) = $this->filingsSentimentWithHttpInfo($access_number);
        return $response;
    }

    /**
     * Operation filingsSentimentWithHttpInfo
     *
     * SEC Sentiment Analysis
     *
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\SECSentimentAnalysis, HTTP status code, HTTP response headers (array of strings)
     */
    public function filingsSentimentWithHttpInfo($access_number)
    {
        $request = $this->filingsSentimentRequest($access_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\SECSentimentAnalysis' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\SECSentimentAnalysis', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\SECSentimentAnalysis';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\SECSentimentAnalysis',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation filingsSentimentAsync
     *
     * SEC Sentiment Analysis
     *
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filingsSentimentAsync($access_number)
    {
        return $this->filingsSentimentAsyncWithHttpInfo($access_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation filingsSentimentAsyncWithHttpInfo
     *
     * SEC Sentiment Analysis
     *
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function filingsSentimentAsyncWithHttpInfo($access_number)
    {
        $returnType = '\Finnhub\Model\SECSentimentAnalysis';
        $request = $this->filingsSentimentRequest($access_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'filingsSentiment'
     *
     * @param  string $access_number Access number of a specific report you want to retrieve data from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function filingsSentimentRequest($access_number)
    {
        // verify the required parameter 'access_number' is set
        if ($access_number === null || (is_array($access_number) && count($access_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $access_number when calling filingsSentiment'
            );
        }

        $resourcePath = '/stock/filings-sentiment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($access_number)) {
            $access_number = ObjectSerializer::serializeCollection($access_number, '', true);
        }
        if ($access_number !== null) {
            $queryParams['accessNumber'] = $access_number;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation financials
     *
     * Financial Statements
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $statement Statement can take 1 of these values &lt;code&gt;bs, ic, cf&lt;/code&gt; for Balance Sheet, Income Statement, Cash Flow respectively. (required)
     * @param  string $freq Frequency can take 1 of these values &lt;code&gt;annual, quarterly, ttm, ytd&lt;/code&gt;.  TTM (Trailing Twelve Months) option is available for Income Statement and Cash Flow. YTD (Year To Date) option is only available for Cash Flow. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\FinancialStatements
     */
    public function financials($symbol, $statement, $freq)
    {
        list($response) = $this->financialsWithHttpInfo($symbol, $statement, $freq);
        return $response;
    }

    /**
     * Operation financialsWithHttpInfo
     *
     * Financial Statements
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $statement Statement can take 1 of these values &lt;code&gt;bs, ic, cf&lt;/code&gt; for Balance Sheet, Income Statement, Cash Flow respectively. (required)
     * @param  string $freq Frequency can take 1 of these values &lt;code&gt;annual, quarterly, ttm, ytd&lt;/code&gt;.  TTM (Trailing Twelve Months) option is available for Income Statement and Cash Flow. YTD (Year To Date) option is only available for Cash Flow. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\FinancialStatements, HTTP status code, HTTP response headers (array of strings)
     */
    public function financialsWithHttpInfo($symbol, $statement, $freq)
    {
        $request = $this->financialsRequest($symbol, $statement, $freq);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\FinancialStatements' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\FinancialStatements', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\FinancialStatements';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\FinancialStatements',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation financialsAsync
     *
     * Financial Statements
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $statement Statement can take 1 of these values &lt;code&gt;bs, ic, cf&lt;/code&gt; for Balance Sheet, Income Statement, Cash Flow respectively. (required)
     * @param  string $freq Frequency can take 1 of these values &lt;code&gt;annual, quarterly, ttm, ytd&lt;/code&gt;.  TTM (Trailing Twelve Months) option is available for Income Statement and Cash Flow. YTD (Year To Date) option is only available for Cash Flow. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function financialsAsync($symbol, $statement, $freq)
    {
        return $this->financialsAsyncWithHttpInfo($symbol, $statement, $freq)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation financialsAsyncWithHttpInfo
     *
     * Financial Statements
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $statement Statement can take 1 of these values &lt;code&gt;bs, ic, cf&lt;/code&gt; for Balance Sheet, Income Statement, Cash Flow respectively. (required)
     * @param  string $freq Frequency can take 1 of these values &lt;code&gt;annual, quarterly, ttm, ytd&lt;/code&gt;.  TTM (Trailing Twelve Months) option is available for Income Statement and Cash Flow. YTD (Year To Date) option is only available for Cash Flow. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function financialsAsyncWithHttpInfo($symbol, $statement, $freq)
    {
        $returnType = '\Finnhub\Model\FinancialStatements';
        $request = $this->financialsRequest($symbol, $statement, $freq);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'financials'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $statement Statement can take 1 of these values &lt;code&gt;bs, ic, cf&lt;/code&gt; for Balance Sheet, Income Statement, Cash Flow respectively. (required)
     * @param  string $freq Frequency can take 1 of these values &lt;code&gt;annual, quarterly, ttm, ytd&lt;/code&gt;.  TTM (Trailing Twelve Months) option is available for Income Statement and Cash Flow. YTD (Year To Date) option is only available for Cash Flow. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function financialsRequest($symbol, $statement, $freq)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling financials'
            );
        }
        // verify the required parameter 'statement' is set
        if ($statement === null || (is_array($statement) && count($statement) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $statement when calling financials'
            );
        }
        // verify the required parameter 'freq' is set
        if ($freq === null || (is_array($freq) && count($freq) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $freq when calling financials'
            );
        }

        $resourcePath = '/stock/financials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($statement)) {
            $statement = ObjectSerializer::serializeCollection($statement, '', true);
        }
        if ($statement !== null) {
            $queryParams['statement'] = $statement;
        }
        // query params
        if (is_array($freq)) {
            $freq = ObjectSerializer::serializeCollection($freq, '', true);
        }
        if ($freq !== null) {
            $queryParams['freq'] = $freq;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation financialsReported
     *
     * Financials As Reported
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve financials from. (optional)
     * @param  string $freq Frequency. Can be either &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt;. (optional)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\FinancialsAsReported
     */
    public function financialsReported($symbol = null, $cik = null, $access_number = null, $freq = null, $from = null, $to = null)
    {
        list($response) = $this->financialsReportedWithHttpInfo($symbol, $cik, $access_number, $freq, $from, $to);
        return $response;
    }

    /**
     * Operation financialsReportedWithHttpInfo
     *
     * Financials As Reported
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve financials from. (optional)
     * @param  string $freq Frequency. Can be either &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt;. (optional)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\FinancialsAsReported, HTTP status code, HTTP response headers (array of strings)
     */
    public function financialsReportedWithHttpInfo($symbol = null, $cik = null, $access_number = null, $freq = null, $from = null, $to = null)
    {
        $request = $this->financialsReportedRequest($symbol, $cik, $access_number, $freq, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\FinancialsAsReported' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\FinancialsAsReported', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\FinancialsAsReported';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\FinancialsAsReported',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation financialsReportedAsync
     *
     * Financials As Reported
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve financials from. (optional)
     * @param  string $freq Frequency. Can be either &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt;. (optional)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function financialsReportedAsync($symbol = null, $cik = null, $access_number = null, $freq = null, $from = null, $to = null)
    {
        return $this->financialsReportedAsyncWithHttpInfo($symbol, $cik, $access_number, $freq, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation financialsReportedAsyncWithHttpInfo
     *
     * Financials As Reported
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve financials from. (optional)
     * @param  string $freq Frequency. Can be either &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt;. (optional)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function financialsReportedAsyncWithHttpInfo($symbol = null, $cik = null, $access_number = null, $freq = null, $from = null, $to = null)
    {
        $returnType = '\Finnhub\Model\FinancialsAsReported';
        $request = $this->financialsReportedRequest($symbol, $cik, $access_number, $freq, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'financialsReported'
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     * @param  string $access_number Access number of a specific report you want to retrieve financials from. (optional)
     * @param  string $freq Frequency. Can be either &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt;. (optional)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for endDate. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function financialsReportedRequest($symbol = null, $cik = null, $access_number = null, $freq = null, $from = null, $to = null)
    {

        $resourcePath = '/stock/financials-reported';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($cik)) {
            $cik = ObjectSerializer::serializeCollection($cik, '', true);
        }
        if ($cik !== null) {
            $queryParams['cik'] = $cik;
        }
        // query params
        if (is_array($access_number)) {
            $access_number = ObjectSerializer::serializeCollection($access_number, '', true);
        }
        if ($access_number !== null) {
            $queryParams['accessNumber'] = $access_number;
        }
        // query params
        if (is_array($freq)) {
            $freq = ObjectSerializer::serializeCollection($freq, '', true);
        }
        if ($freq !== null) {
            $queryParams['freq'] = $freq;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation forexCandles
     *
     * Forex Candles
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/forex/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\ForexCandles
     */
    public function forexCandles($symbol, $resolution, $from, $to)
    {
        list($response) = $this->forexCandlesWithHttpInfo($symbol, $resolution, $from, $to);
        return $response;
    }

    /**
     * Operation forexCandlesWithHttpInfo
     *
     * Forex Candles
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/forex/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\ForexCandles, HTTP status code, HTTP response headers (array of strings)
     */
    public function forexCandlesWithHttpInfo($symbol, $resolution, $from, $to)
    {
        $request = $this->forexCandlesRequest($symbol, $resolution, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\ForexCandles' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\ForexCandles', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\ForexCandles';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\ForexCandles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation forexCandlesAsync
     *
     * Forex Candles
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/forex/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexCandlesAsync($symbol, $resolution, $from, $to)
    {
        return $this->forexCandlesAsyncWithHttpInfo($symbol, $resolution, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forexCandlesAsyncWithHttpInfo
     *
     * Forex Candles
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/forex/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexCandlesAsyncWithHttpInfo($symbol, $resolution, $from, $to)
    {
        $returnType = '\Finnhub\Model\ForexCandles';
        $request = $this->forexCandlesRequest($symbol, $resolution, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forexCandles'
     *
     * @param  string $symbol Use symbol returned in &lt;code&gt;/forex/symbol&lt;/code&gt; endpoint for this field. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forexCandlesRequest($symbol, $resolution, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling forexCandles'
            );
        }
        // verify the required parameter 'resolution' is set
        if ($resolution === null || (is_array($resolution) && count($resolution) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resolution when calling forexCandles'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling forexCandles'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling forexCandles'
            );
        }

        $resourcePath = '/forex/candle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($resolution)) {
            $resolution = ObjectSerializer::serializeCollection($resolution, '', true);
        }
        if ($resolution !== null) {
            $queryParams['resolution'] = $resolution;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation forexExchanges
     *
     * Forex Exchanges
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function forexExchanges()
    {
        list($response) = $this->forexExchangesWithHttpInfo();
        return $response;
    }

    /**
     * Operation forexExchangesWithHttpInfo
     *
     * Forex Exchanges
     *
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function forexExchangesWithHttpInfo()
    {
        $request = $this->forexExchangesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation forexExchangesAsync
     *
     * Forex Exchanges
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexExchangesAsync()
    {
        return $this->forexExchangesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forexExchangesAsyncWithHttpInfo
     *
     * Forex Exchanges
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexExchangesAsyncWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->forexExchangesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forexExchanges'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forexExchangesRequest()
    {

        $resourcePath = '/forex/exchange';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation forexRates
     *
     * Forex rates
     *
     * @param  string $base Base currency. Default to EUR. (optional)
     * @param  string $date Date. Leave blank to get the latest data. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\Forexrates
     */
    public function forexRates($base = null, $date = null)
    {
        list($response) = $this->forexRatesWithHttpInfo($base, $date);
        return $response;
    }

    /**
     * Operation forexRatesWithHttpInfo
     *
     * Forex rates
     *
     * @param  string $base Base currency. Default to EUR. (optional)
     * @param  string $date Date. Leave blank to get the latest data. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\Forexrates, HTTP status code, HTTP response headers (array of strings)
     */
    public function forexRatesWithHttpInfo($base = null, $date = null)
    {
        $request = $this->forexRatesRequest($base, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\Forexrates' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\Forexrates', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\Forexrates';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\Forexrates',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation forexRatesAsync
     *
     * Forex rates
     *
     * @param  string $base Base currency. Default to EUR. (optional)
     * @param  string $date Date. Leave blank to get the latest data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexRatesAsync($base = null, $date = null)
    {
        return $this->forexRatesAsyncWithHttpInfo($base, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forexRatesAsyncWithHttpInfo
     *
     * Forex rates
     *
     * @param  string $base Base currency. Default to EUR. (optional)
     * @param  string $date Date. Leave blank to get the latest data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexRatesAsyncWithHttpInfo($base = null, $date = null)
    {
        $returnType = '\Finnhub\Model\Forexrates';
        $request = $this->forexRatesRequest($base, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forexRates'
     *
     * @param  string $base Base currency. Default to EUR. (optional)
     * @param  string $date Date. Leave blank to get the latest data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forexRatesRequest($base = null, $date = null)
    {

        $resourcePath = '/forex/rates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($base)) {
            $base = ObjectSerializer::serializeCollection($base, '', true);
        }
        if ($base !== null) {
            $queryParams['base'] = $base;
        }
        // query params
        if (is_array($date)) {
            $date = ObjectSerializer::serializeCollection($date, '', true);
        }
        if ($date !== null) {
            $queryParams['date'] = $date;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation forexSymbols
     *
     * Forex Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\ForexSymbol[]
     */
    public function forexSymbols($exchange)
    {
        list($response) = $this->forexSymbolsWithHttpInfo($exchange);
        return $response;
    }

    /**
     * Operation forexSymbolsWithHttpInfo
     *
     * Forex Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\ForexSymbol[], HTTP status code, HTTP response headers (array of strings)
     */
    public function forexSymbolsWithHttpInfo($exchange)
    {
        $request = $this->forexSymbolsRequest($exchange);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\ForexSymbol[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\ForexSymbol[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\ForexSymbol[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\ForexSymbol[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation forexSymbolsAsync
     *
     * Forex Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexSymbolsAsync($exchange)
    {
        return $this->forexSymbolsAsyncWithHttpInfo($exchange)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forexSymbolsAsyncWithHttpInfo
     *
     * Forex Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forexSymbolsAsyncWithHttpInfo($exchange)
    {
        $returnType = '\Finnhub\Model\ForexSymbol[]';
        $request = $this->forexSymbolsRequest($exchange);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forexSymbols'
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forexSymbolsRequest($exchange)
    {
        // verify the required parameter 'exchange' is set
        if ($exchange === null || (is_array($exchange) && count($exchange) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange when calling forexSymbols'
            );
        }

        $resourcePath = '/forex/symbol';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($exchange)) {
            $exchange = ObjectSerializer::serializeCollection($exchange, '', true);
        }
        if ($exchange !== null) {
            $queryParams['exchange'] = $exchange;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fundOwnership
     *
     * Fund Ownership
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\FundOwnership
     */
    public function fundOwnership($symbol, $limit = null)
    {
        list($response) = $this->fundOwnershipWithHttpInfo($symbol, $limit);
        return $response;
    }

    /**
     * Operation fundOwnershipWithHttpInfo
     *
     * Fund Ownership
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\FundOwnership, HTTP status code, HTTP response headers (array of strings)
     */
    public function fundOwnershipWithHttpInfo($symbol, $limit = null)
    {
        $request = $this->fundOwnershipRequest($symbol, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\FundOwnership' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\FundOwnership', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\FundOwnership';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\FundOwnership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fundOwnershipAsync
     *
     * Fund Ownership
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fundOwnershipAsync($symbol, $limit = null)
    {
        return $this->fundOwnershipAsyncWithHttpInfo($symbol, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fundOwnershipAsyncWithHttpInfo
     *
     * Fund Ownership
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fundOwnershipAsyncWithHttpInfo($symbol, $limit = null)
    {
        $returnType = '\Finnhub\Model\FundOwnership';
        $request = $this->fundOwnershipRequest($symbol, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fundOwnership'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fundOwnershipRequest($symbol, $limit = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling fundOwnership'
            );
        }

        $resourcePath = '/stock/fund-ownership';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indicesConstituents
     *
     * Indices Constituents
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\IndicesConstituents
     */
    public function indicesConstituents($symbol)
    {
        list($response) = $this->indicesConstituentsWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation indicesConstituentsWithHttpInfo
     *
     * Indices Constituents
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\IndicesConstituents, HTTP status code, HTTP response headers (array of strings)
     */
    public function indicesConstituentsWithHttpInfo($symbol)
    {
        $request = $this->indicesConstituentsRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\IndicesConstituents' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\IndicesConstituents', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\IndicesConstituents';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\IndicesConstituents',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indicesConstituentsAsync
     *
     * Indices Constituents
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesConstituentsAsync($symbol)
    {
        return $this->indicesConstituentsAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indicesConstituentsAsyncWithHttpInfo
     *
     * Indices Constituents
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesConstituentsAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\IndicesConstituents';
        $request = $this->indicesConstituentsRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indicesConstituents'
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function indicesConstituentsRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling indicesConstituents'
            );
        }

        $resourcePath = '/index/constituents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indicesHistoricalConstituents
     *
     * Indices Historical Constituents
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\IndicesHistoricalConstituents
     */
    public function indicesHistoricalConstituents($symbol)
    {
        list($response) = $this->indicesHistoricalConstituentsWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation indicesHistoricalConstituentsWithHttpInfo
     *
     * Indices Historical Constituents
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\IndicesHistoricalConstituents, HTTP status code, HTTP response headers (array of strings)
     */
    public function indicesHistoricalConstituentsWithHttpInfo($symbol)
    {
        $request = $this->indicesHistoricalConstituentsRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\IndicesHistoricalConstituents' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\IndicesHistoricalConstituents', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\IndicesHistoricalConstituents';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\IndicesHistoricalConstituents',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation indicesHistoricalConstituentsAsync
     *
     * Indices Historical Constituents
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesHistoricalConstituentsAsync($symbol)
    {
        return $this->indicesHistoricalConstituentsAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation indicesHistoricalConstituentsAsyncWithHttpInfo
     *
     * Indices Historical Constituents
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function indicesHistoricalConstituentsAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\IndicesHistoricalConstituents';
        $request = $this->indicesHistoricalConstituentsRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'indicesHistoricalConstituents'
     *
     * @param  string $symbol symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function indicesHistoricalConstituentsRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling indicesHistoricalConstituents'
            );
        }

        $resourcePath = '/index/historical-constituents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insiderSentiment
     *
     * Insider Sentiment
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\InsiderSentiments
     */
    public function insiderSentiment($symbol, $from, $to)
    {
        list($response) = $this->insiderSentimentWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation insiderSentimentWithHttpInfo
     *
     * Insider Sentiment
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\InsiderSentiments, HTTP status code, HTTP response headers (array of strings)
     */
    public function insiderSentimentWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->insiderSentimentRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\InsiderSentiments' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\InsiderSentiments', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\InsiderSentiments';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\InsiderSentiments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insiderSentimentAsync
     *
     * Insider Sentiment
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insiderSentimentAsync($symbol, $from, $to)
    {
        return $this->insiderSentimentAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insiderSentimentAsyncWithHttpInfo
     *
     * Insider Sentiment
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insiderSentimentAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\InsiderSentiments';
        $request = $this->insiderSentimentRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insiderSentiment'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function insiderSentimentRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling insiderSentiment'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling insiderSentiment'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling insiderSentiment'
            );
        }

        $resourcePath = '/stock/insider-sentiment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insiderTransactions
     *
     * Insider Transactions
     *
     * @param  string $symbol Symbol of the company: AAPL. Leave this param blank to get the latest transactions. (required)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\InsiderTransactions
     */
    public function insiderTransactions($symbol, $from = null, $to = null)
    {
        list($response) = $this->insiderTransactionsWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation insiderTransactionsWithHttpInfo
     *
     * Insider Transactions
     *
     * @param  string $symbol Symbol of the company: AAPL. Leave this param blank to get the latest transactions. (required)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\InsiderTransactions, HTTP status code, HTTP response headers (array of strings)
     */
    public function insiderTransactionsWithHttpInfo($symbol, $from = null, $to = null)
    {
        $request = $this->insiderTransactionsRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\InsiderTransactions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\InsiderTransactions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\InsiderTransactions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\InsiderTransactions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insiderTransactionsAsync
     *
     * Insider Transactions
     *
     * @param  string $symbol Symbol of the company: AAPL. Leave this param blank to get the latest transactions. (required)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insiderTransactionsAsync($symbol, $from = null, $to = null)
    {
        return $this->insiderTransactionsAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insiderTransactionsAsyncWithHttpInfo
     *
     * Insider Transactions
     *
     * @param  string $symbol Symbol of the company: AAPL. Leave this param blank to get the latest transactions. (required)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insiderTransactionsAsyncWithHttpInfo($symbol, $from = null, $to = null)
    {
        $returnType = '\Finnhub\Model\InsiderTransactions';
        $request = $this->insiderTransactionsRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insiderTransactions'
     *
     * @param  string $symbol Symbol of the company: AAPL. Leave this param blank to get the latest transactions. (required)
     * @param  \DateTime $from From date: 2020-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function insiderTransactionsRequest($symbol, $from = null, $to = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling insiderTransactions'
            );
        }

        $resourcePath = '/stock/insider-transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation institutionalOwnership
     *
     * Institutional Ownership
     *
     * @param  string $symbol Filter by symbol. (required)
     * @param  string $cusip Filter by CUSIP. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\InstitutionalOwnership
     */
    public function institutionalOwnership($symbol, $cusip, $from, $to)
    {
        list($response) = $this->institutionalOwnershipWithHttpInfo($symbol, $cusip, $from, $to);
        return $response;
    }

    /**
     * Operation institutionalOwnershipWithHttpInfo
     *
     * Institutional Ownership
     *
     * @param  string $symbol Filter by symbol. (required)
     * @param  string $cusip Filter by CUSIP. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\InstitutionalOwnership, HTTP status code, HTTP response headers (array of strings)
     */
    public function institutionalOwnershipWithHttpInfo($symbol, $cusip, $from, $to)
    {
        $request = $this->institutionalOwnershipRequest($symbol, $cusip, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\InstitutionalOwnership' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\InstitutionalOwnership', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\InstitutionalOwnership';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\InstitutionalOwnership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation institutionalOwnershipAsync
     *
     * Institutional Ownership
     *
     * @param  string $symbol Filter by symbol. (required)
     * @param  string $cusip Filter by CUSIP. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function institutionalOwnershipAsync($symbol, $cusip, $from, $to)
    {
        return $this->institutionalOwnershipAsyncWithHttpInfo($symbol, $cusip, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation institutionalOwnershipAsyncWithHttpInfo
     *
     * Institutional Ownership
     *
     * @param  string $symbol Filter by symbol. (required)
     * @param  string $cusip Filter by CUSIP. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function institutionalOwnershipAsyncWithHttpInfo($symbol, $cusip, $from, $to)
    {
        $returnType = '\Finnhub\Model\InstitutionalOwnership';
        $request = $this->institutionalOwnershipRequest($symbol, $cusip, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'institutionalOwnership'
     *
     * @param  string $symbol Filter by symbol. (required)
     * @param  string $cusip Filter by CUSIP. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function institutionalOwnershipRequest($symbol, $cusip, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling institutionalOwnership'
            );
        }
        // verify the required parameter 'cusip' is set
        if ($cusip === null || (is_array($cusip) && count($cusip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cusip when calling institutionalOwnership'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling institutionalOwnership'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling institutionalOwnership'
            );
        }

        $resourcePath = '/institutional/ownership';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($cusip)) {
            $cusip = ObjectSerializer::serializeCollection($cusip, '', true);
        }
        if ($cusip !== null) {
            $queryParams['cusip'] = $cusip;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation institutionalPortfolio
     *
     * Institutional Portfolio
     *
     * @param  string $cik Fund&#39;s CIK. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\InstitutionalPortfolio
     */
    public function institutionalPortfolio($cik, $from, $to)
    {
        list($response) = $this->institutionalPortfolioWithHttpInfo($cik, $from, $to);
        return $response;
    }

    /**
     * Operation institutionalPortfolioWithHttpInfo
     *
     * Institutional Portfolio
     *
     * @param  string $cik Fund&#39;s CIK. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\InstitutionalPortfolio, HTTP status code, HTTP response headers (array of strings)
     */
    public function institutionalPortfolioWithHttpInfo($cik, $from, $to)
    {
        $request = $this->institutionalPortfolioRequest($cik, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\InstitutionalPortfolio' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\InstitutionalPortfolio', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\InstitutionalPortfolio';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\InstitutionalPortfolio',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation institutionalPortfolioAsync
     *
     * Institutional Portfolio
     *
     * @param  string $cik Fund&#39;s CIK. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function institutionalPortfolioAsync($cik, $from, $to)
    {
        return $this->institutionalPortfolioAsyncWithHttpInfo($cik, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation institutionalPortfolioAsyncWithHttpInfo
     *
     * Institutional Portfolio
     *
     * @param  string $cik Fund&#39;s CIK. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function institutionalPortfolioAsyncWithHttpInfo($cik, $from, $to)
    {
        $returnType = '\Finnhub\Model\InstitutionalPortfolio';
        $request = $this->institutionalPortfolioRequest($cik, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'institutionalPortfolio'
     *
     * @param  string $cik Fund&#39;s CIK. (required)
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function institutionalPortfolioRequest($cik, $from, $to)
    {
        // verify the required parameter 'cik' is set
        if ($cik === null || (is_array($cik) && count($cik) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cik when calling institutionalPortfolio'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling institutionalPortfolio'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling institutionalPortfolio'
            );
        }

        $resourcePath = '/institutional/portfolio';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($cik)) {
            $cik = ObjectSerializer::serializeCollection($cik, '', true);
        }
        if ($cik !== null) {
            $queryParams['cik'] = $cik;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation institutionalProfile
     *
     * Institutional Profile
     *
     * @param  string $cik Filter by CIK. Leave blank to get the full list. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\InstitutionalProfile
     */
    public function institutionalProfile($cik = null)
    {
        list($response) = $this->institutionalProfileWithHttpInfo($cik);
        return $response;
    }

    /**
     * Operation institutionalProfileWithHttpInfo
     *
     * Institutional Profile
     *
     * @param  string $cik Filter by CIK. Leave blank to get the full list. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\InstitutionalProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function institutionalProfileWithHttpInfo($cik = null)
    {
        $request = $this->institutionalProfileRequest($cik);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\InstitutionalProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\InstitutionalProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\InstitutionalProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\InstitutionalProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation institutionalProfileAsync
     *
     * Institutional Profile
     *
     * @param  string $cik Filter by CIK. Leave blank to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function institutionalProfileAsync($cik = null)
    {
        return $this->institutionalProfileAsyncWithHttpInfo($cik)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation institutionalProfileAsyncWithHttpInfo
     *
     * Institutional Profile
     *
     * @param  string $cik Filter by CIK. Leave blank to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function institutionalProfileAsyncWithHttpInfo($cik = null)
    {
        $returnType = '\Finnhub\Model\InstitutionalProfile';
        $request = $this->institutionalProfileRequest($cik);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'institutionalProfile'
     *
     * @param  string $cik Filter by CIK. Leave blank to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function institutionalProfileRequest($cik = null)
    {

        $resourcePath = '/institutional/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($cik)) {
            $cik = ObjectSerializer::serializeCollection($cik, '', true);
        }
        if ($cik !== null) {
            $queryParams['cik'] = $cik;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internationalFilings
     *
     * International Filings
     *
     * @param  string $symbol Symbol. Leave empty to list latest filings. (optional)
     * @param  string $country Filter by country using country&#39;s 2-letter code. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\InternationalFiling[]
     */
    public function internationalFilings($symbol = null, $country = null)
    {
        list($response) = $this->internationalFilingsWithHttpInfo($symbol, $country);
        return $response;
    }

    /**
     * Operation internationalFilingsWithHttpInfo
     *
     * International Filings
     *
     * @param  string $symbol Symbol. Leave empty to list latest filings. (optional)
     * @param  string $country Filter by country using country&#39;s 2-letter code. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\InternationalFiling[], HTTP status code, HTTP response headers (array of strings)
     */
    public function internationalFilingsWithHttpInfo($symbol = null, $country = null)
    {
        $request = $this->internationalFilingsRequest($symbol, $country);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\InternationalFiling[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\InternationalFiling[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\InternationalFiling[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\InternationalFiling[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation internationalFilingsAsync
     *
     * International Filings
     *
     * @param  string $symbol Symbol. Leave empty to list latest filings. (optional)
     * @param  string $country Filter by country using country&#39;s 2-letter code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internationalFilingsAsync($symbol = null, $country = null)
    {
        return $this->internationalFilingsAsyncWithHttpInfo($symbol, $country)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internationalFilingsAsyncWithHttpInfo
     *
     * International Filings
     *
     * @param  string $symbol Symbol. Leave empty to list latest filings. (optional)
     * @param  string $country Filter by country using country&#39;s 2-letter code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internationalFilingsAsyncWithHttpInfo($symbol = null, $country = null)
    {
        $returnType = '\Finnhub\Model\InternationalFiling[]';
        $request = $this->internationalFilingsRequest($symbol, $country);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internationalFilings'
     *
     * @param  string $symbol Symbol. Leave empty to list latest filings. (optional)
     * @param  string $country Filter by country using country&#39;s 2-letter code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internationalFilingsRequest($symbol = null, $country = null)
    {

        $resourcePath = '/stock/international-filings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($country)) {
            $country = ObjectSerializer::serializeCollection($country, '', true);
        }
        if ($country !== null) {
            $queryParams['country'] = $country;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation investmentThemes
     *
     * Investment Themes (Thematic Investing)
     *
     * @param  string $theme Investment theme. A full list of themes supported can be found &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp&#x3D;sharing\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\InvestmentThemes
     */
    public function investmentThemes($theme)
    {
        list($response) = $this->investmentThemesWithHttpInfo($theme);
        return $response;
    }

    /**
     * Operation investmentThemesWithHttpInfo
     *
     * Investment Themes (Thematic Investing)
     *
     * @param  string $theme Investment theme. A full list of themes supported can be found &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp&#x3D;sharing\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\InvestmentThemes, HTTP status code, HTTP response headers (array of strings)
     */
    public function investmentThemesWithHttpInfo($theme)
    {
        $request = $this->investmentThemesRequest($theme);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\InvestmentThemes' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\InvestmentThemes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\InvestmentThemes';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\InvestmentThemes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation investmentThemesAsync
     *
     * Investment Themes (Thematic Investing)
     *
     * @param  string $theme Investment theme. A full list of themes supported can be found &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp&#x3D;sharing\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function investmentThemesAsync($theme)
    {
        return $this->investmentThemesAsyncWithHttpInfo($theme)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation investmentThemesAsyncWithHttpInfo
     *
     * Investment Themes (Thematic Investing)
     *
     * @param  string $theme Investment theme. A full list of themes supported can be found &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp&#x3D;sharing\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function investmentThemesAsyncWithHttpInfo($theme)
    {
        $returnType = '\Finnhub\Model\InvestmentThemes';
        $request = $this->investmentThemesRequest($theme);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'investmentThemes'
     *
     * @param  string $theme Investment theme. A full list of themes supported can be found &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ULj9xDh4iPoQj279M084adZ2_S852ttRthKKJ7madYc/edit?usp&#x3D;sharing\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function investmentThemesRequest($theme)
    {
        // verify the required parameter 'theme' is set
        if ($theme === null || (is_array($theme) && count($theme) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $theme when calling investmentThemes'
            );
        }

        $resourcePath = '/stock/investment-theme';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($theme)) {
            $theme = ObjectSerializer::serializeCollection($theme, '', true);
        }
        if ($theme !== null) {
            $queryParams['theme'] = $theme;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ipoCalendar
     *
     * IPO Calendar
     *
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\IPOCalendar
     */
    public function ipoCalendar($from, $to)
    {
        list($response) = $this->ipoCalendarWithHttpInfo($from, $to);
        return $response;
    }

    /**
     * Operation ipoCalendarWithHttpInfo
     *
     * IPO Calendar
     *
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\IPOCalendar, HTTP status code, HTTP response headers (array of strings)
     */
    public function ipoCalendarWithHttpInfo($from, $to)
    {
        $request = $this->ipoCalendarRequest($from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\IPOCalendar' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\IPOCalendar', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\IPOCalendar';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\IPOCalendar',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ipoCalendarAsync
     *
     * IPO Calendar
     *
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipoCalendarAsync($from, $to)
    {
        return $this->ipoCalendarAsyncWithHttpInfo($from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ipoCalendarAsyncWithHttpInfo
     *
     * IPO Calendar
     *
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ipoCalendarAsyncWithHttpInfo($from, $to)
    {
        $returnType = '\Finnhub\Model\IPOCalendar';
        $request = $this->ipoCalendarRequest($from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ipoCalendar'
     *
     * @param  \DateTime $from From date: 2020-03-15. (required)
     * @param  \DateTime $to To date: 2020-03-16. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ipoCalendarRequest($from, $to)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling ipoCalendar'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling ipoCalendar'
            );
        }

        $resourcePath = '/calendar/ipo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation isinChange
     *
     * ISIN Change
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\IsinChange
     */
    public function isinChange($from, $to)
    {
        list($response) = $this->isinChangeWithHttpInfo($from, $to);
        return $response;
    }

    /**
     * Operation isinChangeWithHttpInfo
     *
     * ISIN Change
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\IsinChange, HTTP status code, HTTP response headers (array of strings)
     */
    public function isinChangeWithHttpInfo($from, $to)
    {
        $request = $this->isinChangeRequest($from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\IsinChange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\IsinChange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\IsinChange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\IsinChange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation isinChangeAsync
     *
     * ISIN Change
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function isinChangeAsync($from, $to)
    {
        return $this->isinChangeAsyncWithHttpInfo($from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation isinChangeAsyncWithHttpInfo
     *
     * ISIN Change
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function isinChangeAsyncWithHttpInfo($from, $to)
    {
        $returnType = '\Finnhub\Model\IsinChange';
        $request = $this->isinChangeRequest($from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'isinChange'
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function isinChangeRequest($from, $to)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling isinChange'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling isinChange'
            );
        }

        $resourcePath = '/ca/isin-change';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marketHoliday
     *
     * Market Holiday
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MarketHoliday
     */
    public function marketHoliday($exchange)
    {
        list($response) = $this->marketHolidayWithHttpInfo($exchange);
        return $response;
    }

    /**
     * Operation marketHolidayWithHttpInfo
     *
     * Market Holiday
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MarketHoliday, HTTP status code, HTTP response headers (array of strings)
     */
    public function marketHolidayWithHttpInfo($exchange)
    {
        $request = $this->marketHolidayRequest($exchange);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MarketHoliday' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MarketHoliday', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MarketHoliday';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MarketHoliday',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation marketHolidayAsync
     *
     * Market Holiday
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function marketHolidayAsync($exchange)
    {
        return $this->marketHolidayAsyncWithHttpInfo($exchange)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation marketHolidayAsyncWithHttpInfo
     *
     * Market Holiday
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function marketHolidayAsyncWithHttpInfo($exchange)
    {
        $returnType = '\Finnhub\Model\MarketHoliday';
        $request = $this->marketHolidayRequest($exchange);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'marketHoliday'
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function marketHolidayRequest($exchange)
    {
        // verify the required parameter 'exchange' is set
        if ($exchange === null || (is_array($exchange) && count($exchange) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange when calling marketHoliday'
            );
        }

        $resourcePath = '/stock/market-holiday';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($exchange)) {
            $exchange = ObjectSerializer::serializeCollection($exchange, '', true);
        }
        if ($exchange !== null) {
            $queryParams['exchange'] = $exchange;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marketNews
     *
     * Market News
     *
     * @param  string $category This parameter can be 1 of the following values &lt;code&gt;general, forex, crypto, merger&lt;/code&gt;. (required)
     * @param  int $min_id Use this field to get only news after this ID. Default to 0 (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MarketNews[]
     */
    public function marketNews($category, $min_id = null)
    {
        list($response) = $this->marketNewsWithHttpInfo($category, $min_id);
        return $response;
    }

    /**
     * Operation marketNewsWithHttpInfo
     *
     * Market News
     *
     * @param  string $category This parameter can be 1 of the following values &lt;code&gt;general, forex, crypto, merger&lt;/code&gt;. (required)
     * @param  int $min_id Use this field to get only news after this ID. Default to 0 (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MarketNews[], HTTP status code, HTTP response headers (array of strings)
     */
    public function marketNewsWithHttpInfo($category, $min_id = null)
    {
        $request = $this->marketNewsRequest($category, $min_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MarketNews[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MarketNews[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MarketNews[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MarketNews[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation marketNewsAsync
     *
     * Market News
     *
     * @param  string $category This parameter can be 1 of the following values &lt;code&gt;general, forex, crypto, merger&lt;/code&gt;. (required)
     * @param  int $min_id Use this field to get only news after this ID. Default to 0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function marketNewsAsync($category, $min_id = null)
    {
        return $this->marketNewsAsyncWithHttpInfo($category, $min_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation marketNewsAsyncWithHttpInfo
     *
     * Market News
     *
     * @param  string $category This parameter can be 1 of the following values &lt;code&gt;general, forex, crypto, merger&lt;/code&gt;. (required)
     * @param  int $min_id Use this field to get only news after this ID. Default to 0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function marketNewsAsyncWithHttpInfo($category, $min_id = null)
    {
        $returnType = '\Finnhub\Model\MarketNews[]';
        $request = $this->marketNewsRequest($category, $min_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'marketNews'
     *
     * @param  string $category This parameter can be 1 of the following values &lt;code&gt;general, forex, crypto, merger&lt;/code&gt;. (required)
     * @param  int $min_id Use this field to get only news after this ID. Default to 0 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function marketNewsRequest($category, $min_id = null)
    {
        // verify the required parameter 'category' is set
        if ($category === null || (is_array($category) && count($category) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category when calling marketNews'
            );
        }

        $resourcePath = '/news';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($category)) {
            $category = ObjectSerializer::serializeCollection($category, '', true);
        }
        if ($category !== null) {
            $queryParams['category'] = $category;
        }
        // query params
        if (is_array($min_id)) {
            $min_id = ObjectSerializer::serializeCollection($min_id, '', true);
        }
        if ($min_id !== null) {
            $queryParams['minId'] = $min_id;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marketStatus
     *
     * Market Status
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MarketStatus
     */
    public function marketStatus($exchange)
    {
        list($response) = $this->marketStatusWithHttpInfo($exchange);
        return $response;
    }

    /**
     * Operation marketStatusWithHttpInfo
     *
     * Market Status
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MarketStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function marketStatusWithHttpInfo($exchange)
    {
        $request = $this->marketStatusRequest($exchange);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MarketStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MarketStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MarketStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MarketStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation marketStatusAsync
     *
     * Market Status
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function marketStatusAsync($exchange)
    {
        return $this->marketStatusAsyncWithHttpInfo($exchange)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation marketStatusAsyncWithHttpInfo
     *
     * Market Status
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function marketStatusAsyncWithHttpInfo($exchange)
    {
        $returnType = '\Finnhub\Model\MarketStatus';
        $request = $this->marketStatusRequest($exchange);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'marketStatus'
     *
     * @param  string $exchange Exchange code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function marketStatusRequest($exchange)
    {
        // verify the required parameter 'exchange' is set
        if ($exchange === null || (is_array($exchange) && count($exchange) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange when calling marketStatus'
            );
        }

        $resourcePath = '/stock/market-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($exchange)) {
            $exchange = ObjectSerializer::serializeCollection($exchange, '', true);
        }
        if ($exchange !== null) {
            $queryParams['exchange'] = $exchange;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mutualFundCountryExposure
     *
     * Mutual Funds Country Exposure
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MutualFundCountryExposure
     */
    public function mutualFundCountryExposure($symbol = null, $isin = null)
    {
        list($response) = $this->mutualFundCountryExposureWithHttpInfo($symbol, $isin);
        return $response;
    }

    /**
     * Operation mutualFundCountryExposureWithHttpInfo
     *
     * Mutual Funds Country Exposure
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MutualFundCountryExposure, HTTP status code, HTTP response headers (array of strings)
     */
    public function mutualFundCountryExposureWithHttpInfo($symbol = null, $isin = null)
    {
        $request = $this->mutualFundCountryExposureRequest($symbol, $isin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MutualFundCountryExposure' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MutualFundCountryExposure', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MutualFundCountryExposure';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MutualFundCountryExposure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mutualFundCountryExposureAsync
     *
     * Mutual Funds Country Exposure
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundCountryExposureAsync($symbol = null, $isin = null)
    {
        return $this->mutualFundCountryExposureAsyncWithHttpInfo($symbol, $isin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mutualFundCountryExposureAsyncWithHttpInfo
     *
     * Mutual Funds Country Exposure
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundCountryExposureAsyncWithHttpInfo($symbol = null, $isin = null)
    {
        $returnType = '\Finnhub\Model\MutualFundCountryExposure';
        $request = $this->mutualFundCountryExposureRequest($symbol, $isin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mutualFundCountryExposure'
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mutualFundCountryExposureRequest($symbol = null, $isin = null)
    {

        $resourcePath = '/mutual-fund/country';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mutualFundEet
     *
     * Mutual Funds EET
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MutualFundEet
     */
    public function mutualFundEet($isin)
    {
        list($response) = $this->mutualFundEetWithHttpInfo($isin);
        return $response;
    }

    /**
     * Operation mutualFundEetWithHttpInfo
     *
     * Mutual Funds EET
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MutualFundEet, HTTP status code, HTTP response headers (array of strings)
     */
    public function mutualFundEetWithHttpInfo($isin)
    {
        $request = $this->mutualFundEetRequest($isin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MutualFundEet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MutualFundEet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MutualFundEet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MutualFundEet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mutualFundEetAsync
     *
     * Mutual Funds EET
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundEetAsync($isin)
    {
        return $this->mutualFundEetAsyncWithHttpInfo($isin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mutualFundEetAsyncWithHttpInfo
     *
     * Mutual Funds EET
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundEetAsyncWithHttpInfo($isin)
    {
        $returnType = '\Finnhub\Model\MutualFundEet';
        $request = $this->mutualFundEetRequest($isin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mutualFundEet'
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mutualFundEetRequest($isin)
    {
        // verify the required parameter 'isin' is set
        if ($isin === null || (is_array($isin) && count($isin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $isin when calling mutualFundEet'
            );
        }

        $resourcePath = '/mutual-fund/eet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mutualFundEetPai
     *
     * Mutual Funds EET PAI
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MutualFundEetPai
     */
    public function mutualFundEetPai($isin)
    {
        list($response) = $this->mutualFundEetPaiWithHttpInfo($isin);
        return $response;
    }

    /**
     * Operation mutualFundEetPaiWithHttpInfo
     *
     * Mutual Funds EET PAI
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MutualFundEetPai, HTTP status code, HTTP response headers (array of strings)
     */
    public function mutualFundEetPaiWithHttpInfo($isin)
    {
        $request = $this->mutualFundEetPaiRequest($isin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MutualFundEetPai' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MutualFundEetPai', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MutualFundEetPai';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MutualFundEetPai',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mutualFundEetPaiAsync
     *
     * Mutual Funds EET PAI
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundEetPaiAsync($isin)
    {
        return $this->mutualFundEetPaiAsyncWithHttpInfo($isin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mutualFundEetPaiAsyncWithHttpInfo
     *
     * Mutual Funds EET PAI
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundEetPaiAsyncWithHttpInfo($isin)
    {
        $returnType = '\Finnhub\Model\MutualFundEetPai';
        $request = $this->mutualFundEetPaiRequest($isin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mutualFundEetPai'
     *
     * @param  string $isin ISIN. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mutualFundEetPaiRequest($isin)
    {
        // verify the required parameter 'isin' is set
        if ($isin === null || (is_array($isin) && count($isin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $isin when calling mutualFundEetPai'
            );
        }

        $resourcePath = '/mutual-fund/eet-pai';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mutualFundHoldings
     *
     * Mutual Funds Holdings
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MutualFundHoldings
     */
    public function mutualFundHoldings($symbol = null, $isin = null, $skip = null)
    {
        list($response) = $this->mutualFundHoldingsWithHttpInfo($symbol, $isin, $skip);
        return $response;
    }

    /**
     * Operation mutualFundHoldingsWithHttpInfo
     *
     * Mutual Funds Holdings
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MutualFundHoldings, HTTP status code, HTTP response headers (array of strings)
     */
    public function mutualFundHoldingsWithHttpInfo($symbol = null, $isin = null, $skip = null)
    {
        $request = $this->mutualFundHoldingsRequest($symbol, $isin, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MutualFundHoldings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MutualFundHoldings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MutualFundHoldings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MutualFundHoldings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mutualFundHoldingsAsync
     *
     * Mutual Funds Holdings
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundHoldingsAsync($symbol = null, $isin = null, $skip = null)
    {
        return $this->mutualFundHoldingsAsyncWithHttpInfo($symbol, $isin, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mutualFundHoldingsAsyncWithHttpInfo
     *
     * Mutual Funds Holdings
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundHoldingsAsyncWithHttpInfo($symbol = null, $isin = null, $skip = null)
    {
        $returnType = '\Finnhub\Model\MutualFundHoldings';
        $request = $this->mutualFundHoldingsRequest($symbol, $isin, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mutualFundHoldings'
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     * @param  int $skip Skip the first n results. You can use this parameter to query historical constituents data. The latest result is returned if skip&#x3D;0 or not set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mutualFundHoldingsRequest($symbol = null, $isin = null, $skip = null)
    {

        $resourcePath = '/mutual-fund/holdings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }
        // query params
        if (is_array($skip)) {
            $skip = ObjectSerializer::serializeCollection($skip, '', true);
        }
        if ($skip !== null) {
            $queryParams['skip'] = $skip;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mutualFundProfile
     *
     * Mutual Funds Profile
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MutualFundProfile
     */
    public function mutualFundProfile($symbol = null, $isin = null)
    {
        list($response) = $this->mutualFundProfileWithHttpInfo($symbol, $isin);
        return $response;
    }

    /**
     * Operation mutualFundProfileWithHttpInfo
     *
     * Mutual Funds Profile
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MutualFundProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function mutualFundProfileWithHttpInfo($symbol = null, $isin = null)
    {
        $request = $this->mutualFundProfileRequest($symbol, $isin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MutualFundProfile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MutualFundProfile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MutualFundProfile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MutualFundProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mutualFundProfileAsync
     *
     * Mutual Funds Profile
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundProfileAsync($symbol = null, $isin = null)
    {
        return $this->mutualFundProfileAsyncWithHttpInfo($symbol, $isin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mutualFundProfileAsyncWithHttpInfo
     *
     * Mutual Funds Profile
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundProfileAsyncWithHttpInfo($symbol = null, $isin = null)
    {
        $returnType = '\Finnhub\Model\MutualFundProfile';
        $request = $this->mutualFundProfileRequest($symbol, $isin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mutualFundProfile'
     *
     * @param  string $symbol Fund&#39;s symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mutualFundProfileRequest($symbol = null, $isin = null)
    {

        $resourcePath = '/mutual-fund/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mutualFundSectorExposure
     *
     * Mutual Funds Sector Exposure
     *
     * @param  string $symbol Mutual Fund symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\MutualFundSectorExposure
     */
    public function mutualFundSectorExposure($symbol = null, $isin = null)
    {
        list($response) = $this->mutualFundSectorExposureWithHttpInfo($symbol, $isin);
        return $response;
    }

    /**
     * Operation mutualFundSectorExposureWithHttpInfo
     *
     * Mutual Funds Sector Exposure
     *
     * @param  string $symbol Mutual Fund symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\MutualFundSectorExposure, HTTP status code, HTTP response headers (array of strings)
     */
    public function mutualFundSectorExposureWithHttpInfo($symbol = null, $isin = null)
    {
        $request = $this->mutualFundSectorExposureRequest($symbol, $isin);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\MutualFundSectorExposure' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\MutualFundSectorExposure', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\MutualFundSectorExposure';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\MutualFundSectorExposure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mutualFundSectorExposureAsync
     *
     * Mutual Funds Sector Exposure
     *
     * @param  string $symbol Mutual Fund symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundSectorExposureAsync($symbol = null, $isin = null)
    {
        return $this->mutualFundSectorExposureAsyncWithHttpInfo($symbol, $isin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mutualFundSectorExposureAsyncWithHttpInfo
     *
     * Mutual Funds Sector Exposure
     *
     * @param  string $symbol Mutual Fund symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mutualFundSectorExposureAsyncWithHttpInfo($symbol = null, $isin = null)
    {
        $returnType = '\Finnhub\Model\MutualFundSectorExposure';
        $request = $this->mutualFundSectorExposureRequest($symbol, $isin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mutualFundSectorExposure'
     *
     * @param  string $symbol Mutual Fund symbol. (optional)
     * @param  string $isin Fund&#39;s isin. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mutualFundSectorExposureRequest($symbol = null, $isin = null)
    {

        $resourcePath = '/mutual-fund/sector';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($isin)) {
            $isin = ObjectSerializer::serializeCollection($isin, '', true);
        }
        if ($isin !== null) {
            $queryParams['isin'] = $isin;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newsSentiment
     *
     * News Sentiment
     *
     * @param  string $symbol Company symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\NewsSentiment
     */
    public function newsSentiment($symbol)
    {
        list($response) = $this->newsSentimentWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation newsSentimentWithHttpInfo
     *
     * News Sentiment
     *
     * @param  string $symbol Company symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\NewsSentiment, HTTP status code, HTTP response headers (array of strings)
     */
    public function newsSentimentWithHttpInfo($symbol)
    {
        $request = $this->newsSentimentRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\NewsSentiment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\NewsSentiment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\NewsSentiment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\NewsSentiment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newsSentimentAsync
     *
     * News Sentiment
     *
     * @param  string $symbol Company symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsSentimentAsync($symbol)
    {
        return $this->newsSentimentAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newsSentimentAsyncWithHttpInfo
     *
     * News Sentiment
     *
     * @param  string $symbol Company symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newsSentimentAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\NewsSentiment';
        $request = $this->newsSentimentRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newsSentiment'
     *
     * @param  string $symbol Company symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newsSentimentRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling newsSentiment'
            );
        }

        $resourcePath = '/news-sentiment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ownership
     *
     * Ownership
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\Ownership
     */
    public function ownership($symbol, $limit = null)
    {
        list($response) = $this->ownershipWithHttpInfo($symbol, $limit);
        return $response;
    }

    /**
     * Operation ownershipWithHttpInfo
     *
     * Ownership
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\Ownership, HTTP status code, HTTP response headers (array of strings)
     */
    public function ownershipWithHttpInfo($symbol, $limit = null)
    {
        $request = $this->ownershipRequest($symbol, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\Ownership' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\Ownership', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\Ownership';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\Ownership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ownershipAsync
     *
     * Ownership
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ownershipAsync($symbol, $limit = null)
    {
        return $this->ownershipAsyncWithHttpInfo($symbol, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ownershipAsyncWithHttpInfo
     *
     * Ownership
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ownershipAsyncWithHttpInfo($symbol, $limit = null)
    {
        $returnType = '\Finnhub\Model\Ownership';
        $request = $this->ownershipRequest($symbol, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ownership'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  int $limit Limit number of results. Leave empty to get the full list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ownershipRequest($symbol, $limit = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling ownership'
            );
        }

        $resourcePath = '/stock/ownership';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patternRecognition
     *
     * Pattern Recognition
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\PatternRecognition
     */
    public function patternRecognition($symbol, $resolution)
    {
        list($response) = $this->patternRecognitionWithHttpInfo($symbol, $resolution);
        return $response;
    }

    /**
     * Operation patternRecognitionWithHttpInfo
     *
     * Pattern Recognition
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\PatternRecognition, HTTP status code, HTTP response headers (array of strings)
     */
    public function patternRecognitionWithHttpInfo($symbol, $resolution)
    {
        $request = $this->patternRecognitionRequest($symbol, $resolution);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\PatternRecognition' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\PatternRecognition', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\PatternRecognition';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\PatternRecognition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patternRecognitionAsync
     *
     * Pattern Recognition
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patternRecognitionAsync($symbol, $resolution)
    {
        return $this->patternRecognitionAsyncWithHttpInfo($symbol, $resolution)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patternRecognitionAsyncWithHttpInfo
     *
     * Pattern Recognition
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patternRecognitionAsyncWithHttpInfo($symbol, $resolution)
    {
        $returnType = '\Finnhub\Model\PatternRecognition';
        $request = $this->patternRecognitionRequest($symbol, $resolution);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patternRecognition'
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patternRecognitionRequest($symbol, $resolution)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling patternRecognition'
            );
        }
        // verify the required parameter 'resolution' is set
        if ($resolution === null || (is_array($resolution) && count($resolution) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resolution when calling patternRecognition'
            );
        }

        $resourcePath = '/scan/pattern';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($resolution)) {
            $resolution = ObjectSerializer::serializeCollection($resolution, '', true);
        }
        if ($resolution !== null) {
            $queryParams['resolution'] = $resolution;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pressReleases
     *
     * Major Press Releases
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From time: 2020-01-01. (optional)
     * @param  \DateTime $to To time: 2020-01-05. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\PressRelease
     */
    public function pressReleases($symbol, $from = null, $to = null)
    {
        list($response) = $this->pressReleasesWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation pressReleasesWithHttpInfo
     *
     * Major Press Releases
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From time: 2020-01-01. (optional)
     * @param  \DateTime $to To time: 2020-01-05. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\PressRelease, HTTP status code, HTTP response headers (array of strings)
     */
    public function pressReleasesWithHttpInfo($symbol, $from = null, $to = null)
    {
        $request = $this->pressReleasesRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\PressRelease' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\PressRelease', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\PressRelease';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\PressRelease',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pressReleasesAsync
     *
     * Major Press Releases
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From time: 2020-01-01. (optional)
     * @param  \DateTime $to To time: 2020-01-05. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pressReleasesAsync($symbol, $from = null, $to = null)
    {
        return $this->pressReleasesAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pressReleasesAsyncWithHttpInfo
     *
     * Major Press Releases
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From time: 2020-01-01. (optional)
     * @param  \DateTime $to To time: 2020-01-05. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pressReleasesAsyncWithHttpInfo($symbol, $from = null, $to = null)
    {
        $returnType = '\Finnhub\Model\PressRelease';
        $request = $this->pressReleasesRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pressReleases'
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From time: 2020-01-01. (optional)
     * @param  \DateTime $to To time: 2020-01-05. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pressReleasesRequest($symbol, $from = null, $to = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling pressReleases'
            );
        }

        $resourcePath = '/press-releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation priceMetrics
     *
     * Price Metrics
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $date Get data on a specific date in the past. The data is available weekly so your date will be automatically adjusted to the last day of that week. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\PriceMetrics
     */
    public function priceMetrics($symbol, $date = null)
    {
        list($response) = $this->priceMetricsWithHttpInfo($symbol, $date);
        return $response;
    }

    /**
     * Operation priceMetricsWithHttpInfo
     *
     * Price Metrics
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $date Get data on a specific date in the past. The data is available weekly so your date will be automatically adjusted to the last day of that week. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\PriceMetrics, HTTP status code, HTTP response headers (array of strings)
     */
    public function priceMetricsWithHttpInfo($symbol, $date = null)
    {
        $request = $this->priceMetricsRequest($symbol, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\PriceMetrics' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\PriceMetrics', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\PriceMetrics';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\PriceMetrics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation priceMetricsAsync
     *
     * Price Metrics
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $date Get data on a specific date in the past. The data is available weekly so your date will be automatically adjusted to the last day of that week. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceMetricsAsync($symbol, $date = null)
    {
        return $this->priceMetricsAsyncWithHttpInfo($symbol, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation priceMetricsAsyncWithHttpInfo
     *
     * Price Metrics
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $date Get data on a specific date in the past. The data is available weekly so your date will be automatically adjusted to the last day of that week. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceMetricsAsyncWithHttpInfo($symbol, $date = null)
    {
        $returnType = '\Finnhub\Model\PriceMetrics';
        $request = $this->priceMetricsRequest($symbol, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'priceMetrics'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     * @param  string $date Get data on a specific date in the past. The data is available weekly so your date will be automatically adjusted to the last day of that week. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function priceMetricsRequest($symbol, $date = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling priceMetrics'
            );
        }

        $resourcePath = '/stock/price-metric';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($date)) {
            $date = ObjectSerializer::serializeCollection($date, '', true);
        }
        if ($date !== null) {
            $queryParams['date'] = $date;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation priceTarget
     *
     * Price Target
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\PriceTarget
     */
    public function priceTarget($symbol)
    {
        list($response) = $this->priceTargetWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation priceTargetWithHttpInfo
     *
     * Price Target
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\PriceTarget, HTTP status code, HTTP response headers (array of strings)
     */
    public function priceTargetWithHttpInfo($symbol)
    {
        $request = $this->priceTargetRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\PriceTarget' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\PriceTarget', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\PriceTarget';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\PriceTarget',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation priceTargetAsync
     *
     * Price Target
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceTargetAsync($symbol)
    {
        return $this->priceTargetAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation priceTargetAsyncWithHttpInfo
     *
     * Price Target
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceTargetAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\PriceTarget';
        $request = $this->priceTargetRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'priceTarget'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function priceTargetRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling priceTarget'
            );
        }

        $resourcePath = '/stock/price-target';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quote
     *
     * Quote
     *
     * @param  string $symbol Symbol (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\Quote
     */
    public function quote($symbol)
    {
        list($response) = $this->quoteWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation quoteWithHttpInfo
     *
     * Quote
     *
     * @param  string $symbol Symbol (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\Quote, HTTP status code, HTTP response headers (array of strings)
     */
    public function quoteWithHttpInfo($symbol)
    {
        $request = $this->quoteRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\Quote' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\Quote', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\Quote';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\Quote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quoteAsync
     *
     * Quote
     *
     * @param  string $symbol Symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quoteAsync($symbol)
    {
        return $this->quoteAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quoteAsyncWithHttpInfo
     *
     * Quote
     *
     * @param  string $symbol Symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quoteAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\Quote';
        $request = $this->quoteRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quote'
     *
     * @param  string $symbol Symbol (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function quoteRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling quote'
            );
        }

        $resourcePath = '/quote';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recommendationTrends
     *
     * Recommendation Trends
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\RecommendationTrend[]
     */
    public function recommendationTrends($symbol)
    {
        list($response) = $this->recommendationTrendsWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation recommendationTrendsWithHttpInfo
     *
     * Recommendation Trends
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\RecommendationTrend[], HTTP status code, HTTP response headers (array of strings)
     */
    public function recommendationTrendsWithHttpInfo($symbol)
    {
        $request = $this->recommendationTrendsRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\RecommendationTrend[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\RecommendationTrend[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\RecommendationTrend[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\RecommendationTrend[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recommendationTrendsAsync
     *
     * Recommendation Trends
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recommendationTrendsAsync($symbol)
    {
        return $this->recommendationTrendsAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recommendationTrendsAsyncWithHttpInfo
     *
     * Recommendation Trends
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recommendationTrendsAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\RecommendationTrend[]';
        $request = $this->recommendationTrendsRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recommendationTrends'
     *
     * @param  string $symbol Symbol of the company: AAPL. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recommendationTrendsRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling recommendationTrends'
            );
        }

        $resourcePath = '/stock/recommendation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation revenueBreakdown
     *
     * Revenue Breakdown
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\RevenueBreakdown
     */
    public function revenueBreakdown($symbol = null, $cik = null)
    {
        list($response) = $this->revenueBreakdownWithHttpInfo($symbol, $cik);
        return $response;
    }

    /**
     * Operation revenueBreakdownWithHttpInfo
     *
     * Revenue Breakdown
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\RevenueBreakdown, HTTP status code, HTTP response headers (array of strings)
     */
    public function revenueBreakdownWithHttpInfo($symbol = null, $cik = null)
    {
        $request = $this->revenueBreakdownRequest($symbol, $cik);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\RevenueBreakdown' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\RevenueBreakdown', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\RevenueBreakdown';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\RevenueBreakdown',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation revenueBreakdownAsync
     *
     * Revenue Breakdown
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revenueBreakdownAsync($symbol = null, $cik = null)
    {
        return $this->revenueBreakdownAsyncWithHttpInfo($symbol, $cik)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation revenueBreakdownAsyncWithHttpInfo
     *
     * Revenue Breakdown
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revenueBreakdownAsyncWithHttpInfo($symbol = null, $cik = null)
    {
        $returnType = '\Finnhub\Model\RevenueBreakdown';
        $request = $this->revenueBreakdownRequest($symbol, $cik);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'revenueBreakdown'
     *
     * @param  string $symbol Symbol. (optional)
     * @param  string $cik CIK. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function revenueBreakdownRequest($symbol = null, $cik = null)
    {

        $resourcePath = '/stock/revenue-breakdown';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($cik)) {
            $cik = ObjectSerializer::serializeCollection($cik, '', true);
        }
        if ($cik !== null) {
            $queryParams['cik'] = $cik;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sectorMetric
     *
     * Sector Metrics
     *
     * @param  string $region Region. A list of supported values for this field can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1afedyv7yWJ-z7pMjaAZK-f6ENY3mI3EBCk95QffpoHw/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\SectorMetric
     */
    public function sectorMetric($region)
    {
        list($response) = $this->sectorMetricWithHttpInfo($region);
        return $response;
    }

    /**
     * Operation sectorMetricWithHttpInfo
     *
     * Sector Metrics
     *
     * @param  string $region Region. A list of supported values for this field can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1afedyv7yWJ-z7pMjaAZK-f6ENY3mI3EBCk95QffpoHw/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\SectorMetric, HTTP status code, HTTP response headers (array of strings)
     */
    public function sectorMetricWithHttpInfo($region)
    {
        $request = $this->sectorMetricRequest($region);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\SectorMetric' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\SectorMetric', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\SectorMetric';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\SectorMetric',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sectorMetricAsync
     *
     * Sector Metrics
     *
     * @param  string $region Region. A list of supported values for this field can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1afedyv7yWJ-z7pMjaAZK-f6ENY3mI3EBCk95QffpoHw/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sectorMetricAsync($region)
    {
        return $this->sectorMetricAsyncWithHttpInfo($region)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sectorMetricAsyncWithHttpInfo
     *
     * Sector Metrics
     *
     * @param  string $region Region. A list of supported values for this field can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1afedyv7yWJ-z7pMjaAZK-f6ENY3mI3EBCk95QffpoHw/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sectorMetricAsyncWithHttpInfo($region)
    {
        $returnType = '\Finnhub\Model\SectorMetric';
        $request = $this->sectorMetricRequest($region);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sectorMetric'
     *
     * @param  string $region Region. A list of supported values for this field can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1afedyv7yWJ-z7pMjaAZK-f6ENY3mI3EBCk95QffpoHw/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sectorMetricRequest($region)
    {
        // verify the required parameter 'region' is set
        if ($region === null || (is_array($region) && count($region) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $region when calling sectorMetric'
            );
        }

        $resourcePath = '/sector/metrics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($region)) {
            $region = ObjectSerializer::serializeCollection($region, '', true);
        }
        if ($region !== null) {
            $queryParams['region'] = $region;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation similarityIndex
     *
     * Similarity Index
     *
     * @param  string $symbol Symbol. Required if cik is empty (optional)
     * @param  string $cik CIK. Required if symbol is empty (optional)
     * @param  string $freq &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\SimilarityIndex
     */
    public function similarityIndex($symbol = null, $cik = null, $freq = null)
    {
        list($response) = $this->similarityIndexWithHttpInfo($symbol, $cik, $freq);
        return $response;
    }

    /**
     * Operation similarityIndexWithHttpInfo
     *
     * Similarity Index
     *
     * @param  string $symbol Symbol. Required if cik is empty (optional)
     * @param  string $cik CIK. Required if symbol is empty (optional)
     * @param  string $freq &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt; (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\SimilarityIndex, HTTP status code, HTTP response headers (array of strings)
     */
    public function similarityIndexWithHttpInfo($symbol = null, $cik = null, $freq = null)
    {
        $request = $this->similarityIndexRequest($symbol, $cik, $freq);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\SimilarityIndex' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\SimilarityIndex', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\SimilarityIndex';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\SimilarityIndex',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation similarityIndexAsync
     *
     * Similarity Index
     *
     * @param  string $symbol Symbol. Required if cik is empty (optional)
     * @param  string $cik CIK. Required if symbol is empty (optional)
     * @param  string $freq &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function similarityIndexAsync($symbol = null, $cik = null, $freq = null)
    {
        return $this->similarityIndexAsyncWithHttpInfo($symbol, $cik, $freq)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation similarityIndexAsyncWithHttpInfo
     *
     * Similarity Index
     *
     * @param  string $symbol Symbol. Required if cik is empty (optional)
     * @param  string $cik CIK. Required if symbol is empty (optional)
     * @param  string $freq &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function similarityIndexAsyncWithHttpInfo($symbol = null, $cik = null, $freq = null)
    {
        $returnType = '\Finnhub\Model\SimilarityIndex';
        $request = $this->similarityIndexRequest($symbol, $cik, $freq);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'similarityIndex'
     *
     * @param  string $symbol Symbol. Required if cik is empty (optional)
     * @param  string $cik CIK. Required if symbol is empty (optional)
     * @param  string $freq &lt;code&gt;annual&lt;/code&gt; or &lt;code&gt;quarterly&lt;/code&gt;. Default to &lt;code&gt;annual&lt;/code&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function similarityIndexRequest($symbol = null, $cik = null, $freq = null)
    {

        $resourcePath = '/stock/similarity-index';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($cik)) {
            $cik = ObjectSerializer::serializeCollection($cik, '', true);
        }
        if ($cik !== null) {
            $queryParams['cik'] = $cik;
        }
        // query params
        if (is_array($freq)) {
            $freq = ObjectSerializer::serializeCollection($freq, '', true);
        }
        if ($freq !== null) {
            $queryParams['freq'] = $freq;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation socialSentiment
     *
     * Social Sentiment
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\SocialSentiment
     */
    public function socialSentiment($symbol, $from = null, $to = null)
    {
        list($response) = $this->socialSentimentWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation socialSentimentWithHttpInfo
     *
     * Social Sentiment
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\SocialSentiment, HTTP status code, HTTP response headers (array of strings)
     */
    public function socialSentimentWithHttpInfo($symbol, $from = null, $to = null)
    {
        $request = $this->socialSentimentRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\SocialSentiment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\SocialSentiment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\SocialSentiment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\SocialSentiment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation socialSentimentAsync
     *
     * Social Sentiment
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSentimentAsync($symbol, $from = null, $to = null)
    {
        return $this->socialSentimentAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation socialSentimentAsyncWithHttpInfo
     *
     * Social Sentiment
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function socialSentimentAsyncWithHttpInfo($symbol, $from = null, $to = null)
    {
        $returnType = '\Finnhub\Model\SocialSentiment';
        $request = $this->socialSentimentRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'socialSentiment'
     *
     * @param  string $symbol Company symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function socialSentimentRequest($symbol, $from = null, $to = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling socialSentiment'
            );
        }

        $resourcePath = '/stock/social-sentiment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockBasicDividends
     *
     * Dividends 2 (Basic)
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\Dividends2
     */
    public function stockBasicDividends($symbol)
    {
        list($response) = $this->stockBasicDividendsWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation stockBasicDividendsWithHttpInfo
     *
     * Dividends 2 (Basic)
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\Dividends2, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockBasicDividendsWithHttpInfo($symbol)
    {
        $request = $this->stockBasicDividendsRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\Dividends2' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\Dividends2', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\Dividends2';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\Dividends2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockBasicDividendsAsync
     *
     * Dividends 2 (Basic)
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockBasicDividendsAsync($symbol)
    {
        return $this->stockBasicDividendsAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockBasicDividendsAsyncWithHttpInfo
     *
     * Dividends 2 (Basic)
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockBasicDividendsAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\Dividends2';
        $request = $this->stockBasicDividendsRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockBasicDividends'
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockBasicDividendsRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockBasicDividends'
            );
        }

        $resourcePath = '/stock/dividend2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockBidask
     *
     * Last Bid-Ask
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\LastBidAsk
     */
    public function stockBidask($symbol)
    {
        list($response) = $this->stockBidaskWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation stockBidaskWithHttpInfo
     *
     * Last Bid-Ask
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\LastBidAsk, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockBidaskWithHttpInfo($symbol)
    {
        $request = $this->stockBidaskRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\LastBidAsk' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\LastBidAsk', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\LastBidAsk';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\LastBidAsk',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockBidaskAsync
     *
     * Last Bid-Ask
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockBidaskAsync($symbol)
    {
        return $this->stockBidaskAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockBidaskAsyncWithHttpInfo
     *
     * Last Bid-Ask
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockBidaskAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\LastBidAsk';
        $request = $this->stockBidaskRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockBidask'
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockBidaskRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockBidask'
            );
        }

        $resourcePath = '/stock/bidask';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockCandles
     *
     * Stock Candles
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\StockCandles
     */
    public function stockCandles($symbol, $resolution, $from, $to)
    {
        list($response) = $this->stockCandlesWithHttpInfo($symbol, $resolution, $from, $to);
        return $response;
    }

    /**
     * Operation stockCandlesWithHttpInfo
     *
     * Stock Candles
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\StockCandles, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockCandlesWithHttpInfo($symbol, $resolution, $from, $to)
    {
        $request = $this->stockCandlesRequest($symbol, $resolution, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\StockCandles' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\StockCandles', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\StockCandles';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\StockCandles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockCandlesAsync
     *
     * Stock Candles
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockCandlesAsync($symbol, $resolution, $from, $to)
    {
        return $this->stockCandlesAsyncWithHttpInfo($symbol, $resolution, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockCandlesAsyncWithHttpInfo
     *
     * Stock Candles
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockCandlesAsyncWithHttpInfo($symbol, $resolution, $from, $to)
    {
        $returnType = '\Finnhub\Model\StockCandles';
        $request = $this->stockCandlesRequest($symbol, $resolution, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockCandles'
     *
     * @param  string $symbol Symbol. (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockCandlesRequest($symbol, $resolution, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockCandles'
            );
        }
        // verify the required parameter 'resolution' is set
        if ($resolution === null || (is_array($resolution) && count($resolution) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resolution when calling stockCandles'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling stockCandles'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling stockCandles'
            );
        }

        $resourcePath = '/stock/candle';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($resolution)) {
            $resolution = ObjectSerializer::serializeCollection($resolution, '', true);
        }
        if ($resolution !== null) {
            $queryParams['resolution'] = $resolution;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockDividends
     *
     * Dividends
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\Dividends[]
     */
    public function stockDividends($symbol, $from, $to)
    {
        list($response) = $this->stockDividendsWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation stockDividendsWithHttpInfo
     *
     * Dividends
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\Dividends[], HTTP status code, HTTP response headers (array of strings)
     */
    public function stockDividendsWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->stockDividendsRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\Dividends[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\Dividends[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\Dividends[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\Dividends[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockDividendsAsync
     *
     * Dividends
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockDividendsAsync($symbol, $from, $to)
    {
        return $this->stockDividendsAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockDividendsAsyncWithHttpInfo
     *
     * Dividends
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockDividendsAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\Dividends[]';
        $request = $this->stockDividendsRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockDividends'
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockDividendsRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockDividends'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling stockDividends'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling stockDividends'
            );
        }

        $resourcePath = '/stock/dividend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockLobbying
     *
     * Senate Lobbying
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\LobbyingResult
     */
    public function stockLobbying($symbol, $from, $to)
    {
        list($response) = $this->stockLobbyingWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation stockLobbyingWithHttpInfo
     *
     * Senate Lobbying
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\LobbyingResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockLobbyingWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->stockLobbyingRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\LobbyingResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\LobbyingResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\LobbyingResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\LobbyingResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockLobbyingAsync
     *
     * Senate Lobbying
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockLobbyingAsync($symbol, $from, $to)
    {
        return $this->stockLobbyingAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockLobbyingAsyncWithHttpInfo
     *
     * Senate Lobbying
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockLobbyingAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\LobbyingResult';
        $request = $this->stockLobbyingRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockLobbying'
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockLobbyingRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockLobbying'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling stockLobbying'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling stockLobbying'
            );
        }

        $resourcePath = '/stock/lobbying';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockNbbo
     *
     * Historical NBBO
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\HistoricalNBBO
     */
    public function stockNbbo($symbol, $date, $limit, $skip)
    {
        list($response) = $this->stockNbboWithHttpInfo($symbol, $date, $limit, $skip);
        return $response;
    }

    /**
     * Operation stockNbboWithHttpInfo
     *
     * Historical NBBO
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\HistoricalNBBO, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockNbboWithHttpInfo($symbol, $date, $limit, $skip)
    {
        $request = $this->stockNbboRequest($symbol, $date, $limit, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\HistoricalNBBO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\HistoricalNBBO', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\HistoricalNBBO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\HistoricalNBBO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockNbboAsync
     *
     * Historical NBBO
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockNbboAsync($symbol, $date, $limit, $skip)
    {
        return $this->stockNbboAsyncWithHttpInfo($symbol, $date, $limit, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockNbboAsyncWithHttpInfo
     *
     * Historical NBBO
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockNbboAsyncWithHttpInfo($symbol, $date, $limit, $skip)
    {
        $returnType = '\Finnhub\Model\HistoricalNBBO';
        $request = $this->stockNbboRequest($symbol, $date, $limit, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockNbbo'
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockNbboRequest($symbol, $date, $limit, $skip)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockNbbo'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling stockNbbo'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling stockNbbo'
            );
        }
        // verify the required parameter 'skip' is set
        if ($skip === null || (is_array($skip) && count($skip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $skip when calling stockNbbo'
            );
        }

        $resourcePath = '/stock/bbo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($date)) {
            $date = ObjectSerializer::serializeCollection($date, '', true);
        }
        if ($date !== null) {
            $queryParams['date'] = $date;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($skip)) {
            $skip = ObjectSerializer::serializeCollection($skip, '', true);
        }
        if ($skip !== null) {
            $queryParams['skip'] = $skip;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockSplits
     *
     * Splits
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\Split[]
     */
    public function stockSplits($symbol, $from, $to)
    {
        list($response) = $this->stockSplitsWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation stockSplitsWithHttpInfo
     *
     * Splits
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\Split[], HTTP status code, HTTP response headers (array of strings)
     */
    public function stockSplitsWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->stockSplitsRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\Split[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\Split[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\Split[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\Split[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockSplitsAsync
     *
     * Splits
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockSplitsAsync($symbol, $from, $to)
    {
        return $this->stockSplitsAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockSplitsAsyncWithHttpInfo
     *
     * Splits
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockSplitsAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\Split[]';
        $request = $this->stockSplitsRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockSplits'
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from YYYY-MM-DD. (required)
     * @param  \DateTime $to YYYY-MM-DD. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockSplitsRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockSplits'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling stockSplits'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling stockSplits'
            );
        }

        $resourcePath = '/stock/split';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockSymbols
     *
     * Stock Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. List of exchange codes can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  string $mic Filter by MIC code. (optional)
     * @param  string $security_type Filter by security type used by OpenFigi standard. (optional)
     * @param  string $currency Filter by currency. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\StockSymbol[]
     */
    public function stockSymbols($exchange, $mic = null, $security_type = null, $currency = null)
    {
        list($response) = $this->stockSymbolsWithHttpInfo($exchange, $mic, $security_type, $currency);
        return $response;
    }

    /**
     * Operation stockSymbolsWithHttpInfo
     *
     * Stock Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. List of exchange codes can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  string $mic Filter by MIC code. (optional)
     * @param  string $security_type Filter by security type used by OpenFigi standard. (optional)
     * @param  string $currency Filter by currency. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\StockSymbol[], HTTP status code, HTTP response headers (array of strings)
     */
    public function stockSymbolsWithHttpInfo($exchange, $mic = null, $security_type = null, $currency = null)
    {
        $request = $this->stockSymbolsRequest($exchange, $mic, $security_type, $currency);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\StockSymbol[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\StockSymbol[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\StockSymbol[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\StockSymbol[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockSymbolsAsync
     *
     * Stock Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. List of exchange codes can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  string $mic Filter by MIC code. (optional)
     * @param  string $security_type Filter by security type used by OpenFigi standard. (optional)
     * @param  string $currency Filter by currency. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockSymbolsAsync($exchange, $mic = null, $security_type = null, $currency = null)
    {
        return $this->stockSymbolsAsyncWithHttpInfo($exchange, $mic, $security_type, $currency)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockSymbolsAsyncWithHttpInfo
     *
     * Stock Symbol
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. List of exchange codes can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  string $mic Filter by MIC code. (optional)
     * @param  string $security_type Filter by security type used by OpenFigi standard. (optional)
     * @param  string $currency Filter by currency. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockSymbolsAsyncWithHttpInfo($exchange, $mic = null, $security_type = null, $currency = null)
    {
        $returnType = '\Finnhub\Model\StockSymbol[]';
        $request = $this->stockSymbolsRequest($exchange, $mic, $security_type, $currency);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockSymbols'
     *
     * @param  string $exchange Exchange you want to get the list of symbols from. List of exchange codes can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1I3pBxjfXB056-g_JYf_6o3Rns3BV2kMGG1nCatb91ls/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  string $mic Filter by MIC code. (optional)
     * @param  string $security_type Filter by security type used by OpenFigi standard. (optional)
     * @param  string $currency Filter by currency. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockSymbolsRequest($exchange, $mic = null, $security_type = null, $currency = null)
    {
        // verify the required parameter 'exchange' is set
        if ($exchange === null || (is_array($exchange) && count($exchange) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exchange when calling stockSymbols'
            );
        }

        $resourcePath = '/stock/symbol';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($exchange)) {
            $exchange = ObjectSerializer::serializeCollection($exchange, '', true);
        }
        if ($exchange !== null) {
            $queryParams['exchange'] = $exchange;
        }
        // query params
        if (is_array($mic)) {
            $mic = ObjectSerializer::serializeCollection($mic, '', true);
        }
        if ($mic !== null) {
            $queryParams['mic'] = $mic;
        }
        // query params
        if (is_array($security_type)) {
            $security_type = ObjectSerializer::serializeCollection($security_type, '', true);
        }
        if ($security_type !== null) {
            $queryParams['securityType'] = $security_type;
        }
        // query params
        if (is_array($currency)) {
            $currency = ObjectSerializer::serializeCollection($currency, '', true);
        }
        if ($currency !== null) {
            $queryParams['currency'] = $currency;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockTick
     *
     * Tick Data
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\TickData
     */
    public function stockTick($symbol, $date, $limit, $skip)
    {
        list($response) = $this->stockTickWithHttpInfo($symbol, $date, $limit, $skip);
        return $response;
    }

    /**
     * Operation stockTickWithHttpInfo
     *
     * Tick Data
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\TickData, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockTickWithHttpInfo($symbol, $date, $limit, $skip)
    {
        $request = $this->stockTickRequest($symbol, $date, $limit, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\TickData' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\TickData', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\TickData';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\TickData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockTickAsync
     *
     * Tick Data
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockTickAsync($symbol, $date, $limit, $skip)
    {
        return $this->stockTickAsyncWithHttpInfo($symbol, $date, $limit, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockTickAsyncWithHttpInfo
     *
     * Tick Data
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockTickAsyncWithHttpInfo($symbol, $date, $limit, $skip)
    {
        $returnType = '\Finnhub\Model\TickData';
        $request = $this->stockTickRequest($symbol, $date, $limit, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockTick'
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $date Date: 2020-04-02. (required)
     * @param  int $limit Limit number of ticks returned. Maximum value: &lt;code&gt;25000&lt;/code&gt; (required)
     * @param  int $skip Number of ticks to skip. Use this parameter to loop through the entire data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockTickRequest($symbol, $date, $limit, $skip)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockTick'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling stockTick'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling stockTick'
            );
        }
        // verify the required parameter 'skip' is set
        if ($skip === null || (is_array($skip) && count($skip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $skip when calling stockTick'
            );
        }

        $resourcePath = '/stock/tick';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($date)) {
            $date = ObjectSerializer::serializeCollection($date, '', true);
        }
        if ($date !== null) {
            $queryParams['date'] = $date;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($skip)) {
            $skip = ObjectSerializer::serializeCollection($skip, '', true);
        }
        if ($skip !== null) {
            $queryParams['skip'] = $skip;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockUsaSpending
     *
     * USA Spending
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\UsaSpendingResult
     */
    public function stockUsaSpending($symbol, $from, $to)
    {
        list($response) = $this->stockUsaSpendingWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation stockUsaSpendingWithHttpInfo
     *
     * USA Spending
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\UsaSpendingResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockUsaSpendingWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->stockUsaSpendingRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\UsaSpendingResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\UsaSpendingResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\UsaSpendingResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\UsaSpendingResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockUsaSpendingAsync
     *
     * USA Spending
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockUsaSpendingAsync($symbol, $from, $to)
    {
        return $this->stockUsaSpendingAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockUsaSpendingAsyncWithHttpInfo
     *
     * USA Spending
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockUsaSpendingAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\UsaSpendingResult';
        $request = $this->stockUsaSpendingRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockUsaSpending'
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter for &lt;code&gt;actionDate&lt;/code&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockUsaSpendingRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockUsaSpending'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling stockUsaSpending'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling stockUsaSpending'
            );
        }

        $resourcePath = '/stock/usa-spending';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockUsptoPatent
     *
     * USPTO Patents
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\UsptoPatentResult
     */
    public function stockUsptoPatent($symbol, $from, $to)
    {
        list($response) = $this->stockUsptoPatentWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation stockUsptoPatentWithHttpInfo
     *
     * USPTO Patents
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\UsptoPatentResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockUsptoPatentWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->stockUsptoPatentRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\UsptoPatentResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\UsptoPatentResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\UsptoPatentResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\UsptoPatentResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockUsptoPatentAsync
     *
     * USPTO Patents
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockUsptoPatentAsync($symbol, $from, $to)
    {
        return $this->stockUsptoPatentAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockUsptoPatentAsyncWithHttpInfo
     *
     * USPTO Patents
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockUsptoPatentAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\UsptoPatentResult';
        $request = $this->stockUsptoPatentRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockUsptoPatent'
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockUsptoPatentRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockUsptoPatent'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling stockUsptoPatent'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling stockUsptoPatent'
            );
        }

        $resourcePath = '/stock/uspto-patent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stockVisaApplication
     *
     * H1-B Visa Application
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\VisaApplicationResult
     */
    public function stockVisaApplication($symbol, $from, $to)
    {
        list($response) = $this->stockVisaApplicationWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation stockVisaApplicationWithHttpInfo
     *
     * H1-B Visa Application
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\VisaApplicationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function stockVisaApplicationWithHttpInfo($symbol, $from, $to)
    {
        $request = $this->stockVisaApplicationRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\VisaApplicationResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\VisaApplicationResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\VisaApplicationResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\VisaApplicationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stockVisaApplicationAsync
     *
     * H1-B Visa Application
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockVisaApplicationAsync($symbol, $from, $to)
    {
        return $this->stockVisaApplicationAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stockVisaApplicationAsyncWithHttpInfo
     *
     * H1-B Visa Application
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stockVisaApplicationAsyncWithHttpInfo($symbol, $from, $to)
    {
        $returnType = '\Finnhub\Model\VisaApplicationResult';
        $request = $this->stockVisaApplicationRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stockVisaApplication'
     *
     * @param  string $symbol Symbol. (required)
     * @param  \DateTime $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     * @param  \DateTime $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. Filter on the &lt;code&gt;beginDate&lt;/code&gt; column. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stockVisaApplicationRequest($symbol, $from, $to)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling stockVisaApplication'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling stockVisaApplication'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling stockVisaApplication'
            );
        }

        $resourcePath = '/stock/visa-application';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplyChainRelationships
     *
     * Supply Chain Relationships
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\SupplyChainRelationships
     */
    public function supplyChainRelationships($symbol)
    {
        list($response) = $this->supplyChainRelationshipsWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation supplyChainRelationshipsWithHttpInfo
     *
     * Supply Chain Relationships
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\SupplyChainRelationships, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplyChainRelationshipsWithHttpInfo($symbol)
    {
        $request = $this->supplyChainRelationshipsRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\SupplyChainRelationships' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\SupplyChainRelationships', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\SupplyChainRelationships';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\SupplyChainRelationships',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplyChainRelationshipsAsync
     *
     * Supply Chain Relationships
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplyChainRelationshipsAsync($symbol)
    {
        return $this->supplyChainRelationshipsAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplyChainRelationshipsAsyncWithHttpInfo
     *
     * Supply Chain Relationships
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplyChainRelationshipsAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\SupplyChainRelationships';
        $request = $this->supplyChainRelationshipsRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplyChainRelationships'
     *
     * @param  string $symbol Symbol. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplyChainRelationshipsRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling supplyChainRelationships'
            );
        }

        $resourcePath = '/stock/supply-chain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supportResistance
     *
     * Support/Resistance
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\SupportResistance
     */
    public function supportResistance($symbol, $resolution)
    {
        list($response) = $this->supportResistanceWithHttpInfo($symbol, $resolution);
        return $response;
    }

    /**
     * Operation supportResistanceWithHttpInfo
     *
     * Support/Resistance
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\SupportResistance, HTTP status code, HTTP response headers (array of strings)
     */
    public function supportResistanceWithHttpInfo($symbol, $resolution)
    {
        $request = $this->supportResistanceRequest($symbol, $resolution);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\SupportResistance' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\SupportResistance', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\SupportResistance';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\SupportResistance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supportResistanceAsync
     *
     * Support/Resistance
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supportResistanceAsync($symbol, $resolution)
    {
        return $this->supportResistanceAsyncWithHttpInfo($symbol, $resolution)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supportResistanceAsyncWithHttpInfo
     *
     * Support/Resistance
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supportResistanceAsyncWithHttpInfo($symbol, $resolution)
    {
        $returnType = '\Finnhub\Model\SupportResistance';
        $request = $this->supportResistanceRequest($symbol, $resolution);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supportResistance'
     *
     * @param  string $symbol Symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supportResistanceRequest($symbol, $resolution)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling supportResistance'
            );
        }
        // verify the required parameter 'resolution' is set
        if ($resolution === null || (is_array($resolution) && count($resolution) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resolution when calling supportResistance'
            );
        }

        $resourcePath = '/scan/support-resistance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($resolution)) {
            $resolution = ObjectSerializer::serializeCollection($resolution, '', true);
        }
        if ($resolution !== null) {
            $queryParams['resolution'] = $resolution;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation symbolChange
     *
     * Symbol Change
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\SymbolChange
     */
    public function symbolChange($from, $to)
    {
        list($response) = $this->symbolChangeWithHttpInfo($from, $to);
        return $response;
    }

    /**
     * Operation symbolChangeWithHttpInfo
     *
     * Symbol Change
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\SymbolChange, HTTP status code, HTTP response headers (array of strings)
     */
    public function symbolChangeWithHttpInfo($from, $to)
    {
        $request = $this->symbolChangeRequest($from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\SymbolChange' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\SymbolChange', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\SymbolChange';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\SymbolChange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation symbolChangeAsync
     *
     * Symbol Change
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function symbolChangeAsync($from, $to)
    {
        return $this->symbolChangeAsyncWithHttpInfo($from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation symbolChangeAsyncWithHttpInfo
     *
     * Symbol Change
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function symbolChangeAsyncWithHttpInfo($from, $to)
    {
        $returnType = '\Finnhub\Model\SymbolChange';
        $request = $this->symbolChangeRequest($from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'symbolChange'
     *
     * @param  string $from From date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     * @param  string $to To date &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function symbolChangeRequest($from, $to)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling symbolChange'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling symbolChange'
            );
        }

        $resourcePath = '/ca/symbol-change';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation symbolSearch
     *
     * Symbol Lookup
     *
     * @param  string $q Query text can be symbol, name, isin, or cusip. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\SymbolLookup
     */
    public function symbolSearch($q)
    {
        list($response) = $this->symbolSearchWithHttpInfo($q);
        return $response;
    }

    /**
     * Operation symbolSearchWithHttpInfo
     *
     * Symbol Lookup
     *
     * @param  string $q Query text can be symbol, name, isin, or cusip. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\SymbolLookup, HTTP status code, HTTP response headers (array of strings)
     */
    public function symbolSearchWithHttpInfo($q)
    {
        $request = $this->symbolSearchRequest($q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\SymbolLookup' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\SymbolLookup', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\SymbolLookup';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\SymbolLookup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation symbolSearchAsync
     *
     * Symbol Lookup
     *
     * @param  string $q Query text can be symbol, name, isin, or cusip. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function symbolSearchAsync($q)
    {
        return $this->symbolSearchAsyncWithHttpInfo($q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation symbolSearchAsyncWithHttpInfo
     *
     * Symbol Lookup
     *
     * @param  string $q Query text can be symbol, name, isin, or cusip. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function symbolSearchAsyncWithHttpInfo($q)
    {
        $returnType = '\Finnhub\Model\SymbolLookup';
        $request = $this->symbolSearchRequest($q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'symbolSearch'
     *
     * @param  string $q Query text can be symbol, name, isin, or cusip. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function symbolSearchRequest($q)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling symbolSearch'
            );
        }

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($q)) {
            $q = ObjectSerializer::serializeCollection($q, '', true);
        }
        if ($q !== null) {
            $queryParams['q'] = $q;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation technicalIndicator
     *
     * Technical Indicators
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     * @param  string $indicator Indicator name. Full list can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  object $indicator_fields Check out &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;this page&lt;/a&gt; to see which indicators and params are supported. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function technicalIndicator($symbol, $resolution, $from, $to, $indicator, $indicator_fields = null)
    {
        list($response) = $this->technicalIndicatorWithHttpInfo($symbol, $resolution, $from, $to, $indicator, $indicator_fields);
        return $response;
    }

    /**
     * Operation technicalIndicatorWithHttpInfo
     *
     * Technical Indicators
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     * @param  string $indicator Indicator name. Full list can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  object $indicator_fields Check out &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;this page&lt;/a&gt; to see which indicators and params are supported. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function technicalIndicatorWithHttpInfo($symbol, $resolution, $from, $to, $indicator, $indicator_fields = null)
    {
        $request = $this->technicalIndicatorRequest($symbol, $resolution, $from, $to, $indicator, $indicator_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation technicalIndicatorAsync
     *
     * Technical Indicators
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     * @param  string $indicator Indicator name. Full list can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  object $indicator_fields Check out &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;this page&lt;/a&gt; to see which indicators and params are supported. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function technicalIndicatorAsync($symbol, $resolution, $from, $to, $indicator, $indicator_fields = null)
    {
        return $this->technicalIndicatorAsyncWithHttpInfo($symbol, $resolution, $from, $to, $indicator, $indicator_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation technicalIndicatorAsyncWithHttpInfo
     *
     * Technical Indicators
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     * @param  string $indicator Indicator name. Full list can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  object $indicator_fields Check out &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;this page&lt;/a&gt; to see which indicators and params are supported. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function technicalIndicatorAsyncWithHttpInfo($symbol, $resolution, $from, $to, $indicator, $indicator_fields = null)
    {
        $returnType = 'object';
        $request = $this->technicalIndicatorRequest($symbol, $resolution, $from, $to, $indicator, $indicator_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'technicalIndicator'
     *
     * @param  string $symbol symbol (required)
     * @param  string $resolution Supported resolution includes &lt;code&gt;1, 5, 15, 30, 60, D, W, M &lt;/code&gt;.Some timeframes might not be available depending on the exchange. (required)
     * @param  int $from UNIX timestamp. Interval initial value. (required)
     * @param  int $to UNIX timestamp. Interval end value. (required)
     * @param  string $indicator Indicator name. Full list can be found &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt;. (required)
     * @param  object $indicator_fields Check out &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1ylUvKHVYN2E87WdwIza8ROaCpd48ggEl1k5i5SgA29k/edit?usp&#x3D;sharing\&quot; target&#x3D;\&quot;_blank\&quot;&gt;this page&lt;/a&gt; to see which indicators and params are supported. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function technicalIndicatorRequest($symbol, $resolution, $from, $to, $indicator, $indicator_fields = null)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling technicalIndicator'
            );
        }
        // verify the required parameter 'resolution' is set
        if ($resolution === null || (is_array($resolution) && count($resolution) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resolution when calling technicalIndicator'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling technicalIndicator'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling technicalIndicator'
            );
        }
        // verify the required parameter 'indicator' is set
        if ($indicator === null || (is_array($indicator) && count($indicator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $indicator when calling technicalIndicator'
            );
        }

        $resourcePath = '/indicator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($resolution)) {
            $resolution = ObjectSerializer::serializeCollection($resolution, '', true);
        }
        if ($resolution !== null) {
            $queryParams['resolution'] = $resolution;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }
        // query params
        if (is_array($indicator)) {
            $indicator = ObjectSerializer::serializeCollection($indicator, '', true);
        }
        if ($indicator !== null) {
            $queryParams['indicator'] = $indicator;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($indicator_fields)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($indicator_fields));
            } else {
                $httpBody = $indicator_fields;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transcripts
     *
     * Earnings Call Transcripts
     *
     * @param  string $id Transcript&#39;s id obtained with &lt;a href&#x3D;\&quot;#transcripts-list\&quot;&gt;Transcripts List endpoint&lt;/a&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EarningsCallTranscripts
     */
    public function transcripts($id)
    {
        list($response) = $this->transcriptsWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation transcriptsWithHttpInfo
     *
     * Earnings Call Transcripts
     *
     * @param  string $id Transcript&#39;s id obtained with &lt;a href&#x3D;\&quot;#transcripts-list\&quot;&gt;Transcripts List endpoint&lt;/a&gt;. (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EarningsCallTranscripts, HTTP status code, HTTP response headers (array of strings)
     */
    public function transcriptsWithHttpInfo($id)
    {
        $request = $this->transcriptsRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EarningsCallTranscripts' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EarningsCallTranscripts', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EarningsCallTranscripts';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EarningsCallTranscripts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transcriptsAsync
     *
     * Earnings Call Transcripts
     *
     * @param  string $id Transcript&#39;s id obtained with &lt;a href&#x3D;\&quot;#transcripts-list\&quot;&gt;Transcripts List endpoint&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transcriptsAsync($id)
    {
        return $this->transcriptsAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transcriptsAsyncWithHttpInfo
     *
     * Earnings Call Transcripts
     *
     * @param  string $id Transcript&#39;s id obtained with &lt;a href&#x3D;\&quot;#transcripts-list\&quot;&gt;Transcripts List endpoint&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transcriptsAsyncWithHttpInfo($id)
    {
        $returnType = '\Finnhub\Model\EarningsCallTranscripts';
        $request = $this->transcriptsRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transcripts'
     *
     * @param  string $id Transcript&#39;s id obtained with &lt;a href&#x3D;\&quot;#transcripts-list\&quot;&gt;Transcripts List endpoint&lt;/a&gt;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transcriptsRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling transcripts'
            );
        }

        $resourcePath = '/stock/transcripts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, '', true);
        }
        if ($id !== null) {
            $queryParams['id'] = $id;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transcriptsList
     *
     * Earnings Call Transcripts List
     *
     * @param  string $symbol Company symbol: AAPL. Leave empty to list the latest transcripts (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\EarningsCallTranscriptsList
     */
    public function transcriptsList($symbol)
    {
        list($response) = $this->transcriptsListWithHttpInfo($symbol);
        return $response;
    }

    /**
     * Operation transcriptsListWithHttpInfo
     *
     * Earnings Call Transcripts List
     *
     * @param  string $symbol Company symbol: AAPL. Leave empty to list the latest transcripts (required)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\EarningsCallTranscriptsList, HTTP status code, HTTP response headers (array of strings)
     */
    public function transcriptsListWithHttpInfo($symbol)
    {
        $request = $this->transcriptsListRequest($symbol);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\EarningsCallTranscriptsList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\EarningsCallTranscriptsList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\EarningsCallTranscriptsList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\EarningsCallTranscriptsList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transcriptsListAsync
     *
     * Earnings Call Transcripts List
     *
     * @param  string $symbol Company symbol: AAPL. Leave empty to list the latest transcripts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transcriptsListAsync($symbol)
    {
        return $this->transcriptsListAsyncWithHttpInfo($symbol)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transcriptsListAsyncWithHttpInfo
     *
     * Earnings Call Transcripts List
     *
     * @param  string $symbol Company symbol: AAPL. Leave empty to list the latest transcripts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transcriptsListAsyncWithHttpInfo($symbol)
    {
        $returnType = '\Finnhub\Model\EarningsCallTranscriptsList';
        $request = $this->transcriptsListRequest($symbol);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transcriptsList'
     *
     * @param  string $symbol Company symbol: AAPL. Leave empty to list the latest transcripts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transcriptsListRequest($symbol)
    {
        // verify the required parameter 'symbol' is set
        if ($symbol === null || (is_array($symbol) && count($symbol) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling transcriptsList'
            );
        }

        $resourcePath = '/stock/transcripts/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation upgradeDowngrade
     *
     * Stock Upgrade/Downgrade
     *
     * @param  string $symbol Symbol of the company: AAPL. If left blank, the API will return latest stock upgrades/downgrades. (optional)
     * @param  \DateTime $from From date: 2000-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Finnhub\Model\UpgradeDowngrade[]
     */
    public function upgradeDowngrade($symbol = null, $from = null, $to = null)
    {
        list($response) = $this->upgradeDowngradeWithHttpInfo($symbol, $from, $to);
        return $response;
    }

    /**
     * Operation upgradeDowngradeWithHttpInfo
     *
     * Stock Upgrade/Downgrade
     *
     * @param  string $symbol Symbol of the company: AAPL. If left blank, the API will return latest stock upgrades/downgrades. (optional)
     * @param  \DateTime $from From date: 2000-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \Finnhub\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Finnhub\Model\UpgradeDowngrade[], HTTP status code, HTTP response headers (array of strings)
     */
    public function upgradeDowngradeWithHttpInfo($symbol = null, $from = null, $to = null)
    {
        $request = $this->upgradeDowngradeRequest($symbol, $from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Finnhub\Model\UpgradeDowngrade[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Finnhub\Model\UpgradeDowngrade[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Finnhub\Model\UpgradeDowngrade[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Finnhub\Model\UpgradeDowngrade[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation upgradeDowngradeAsync
     *
     * Stock Upgrade/Downgrade
     *
     * @param  string $symbol Symbol of the company: AAPL. If left blank, the API will return latest stock upgrades/downgrades. (optional)
     * @param  \DateTime $from From date: 2000-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function upgradeDowngradeAsync($symbol = null, $from = null, $to = null)
    {
        return $this->upgradeDowngradeAsyncWithHttpInfo($symbol, $from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation upgradeDowngradeAsyncWithHttpInfo
     *
     * Stock Upgrade/Downgrade
     *
     * @param  string $symbol Symbol of the company: AAPL. If left blank, the API will return latest stock upgrades/downgrades. (optional)
     * @param  \DateTime $from From date: 2000-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function upgradeDowngradeAsyncWithHttpInfo($symbol = null, $from = null, $to = null)
    {
        $returnType = '\Finnhub\Model\UpgradeDowngrade[]';
        $request = $this->upgradeDowngradeRequest($symbol, $from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'upgradeDowngrade'
     *
     * @param  string $symbol Symbol of the company: AAPL. If left blank, the API will return latest stock upgrades/downgrades. (optional)
     * @param  \DateTime $from From date: 2000-03-15. (optional)
     * @param  \DateTime $to To date: 2020-03-16. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function upgradeDowngradeRequest($symbol = null, $from = null, $to = null)
    {

        $resourcePath = '/stock/upgrade-downgrade';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($symbol)) {
            $symbol = ObjectSerializer::serializeCollection($symbol, '', true);
        }
        if ($symbol !== null) {
            $queryParams['symbol'] = $symbol;
        }
        // query params
        if (is_array($from)) {
            $from = ObjectSerializer::serializeCollection($from, '', true);
        }
        if ($from !== null) {
            $queryParams['from'] = $from;
        }
        // query params
        if (is_array($to)) {
            $to = ObjectSerializer::serializeCollection($to, '', true);
        }
        if ($to !== null) {
            $queryParams['to'] = $to;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
